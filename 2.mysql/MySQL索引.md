# 索引基础
## 什么是索引
- 索引：帮助数据库的存储引擎快速定位符合条件的行数据的数据结构，使用索引可避免全表扫描，提高查询效率
## 索引的分类
### 按数据结构分类
- 从数据结构的角度来看，MySQL索引可分为B+Tree索引、Hash索引、Full Text索引

- 每种存储引擎支持的索引类型不一定相同，常见的InnoDB、MyISAM、Memory引擎分别支持的索引类型总结如下：

  |   索引类型    |               InnoDB引擎               | MyISAM引擎 | Memory引擎 |
  | :-----------: | :------------------------------------: | :--------: | :--------: |
  |  B+Tree索引   |                  支持                  |    支持    |    支持    |
  |   Hash索引    | 不支持（但在内存结构有自适应hash索引） |   不支持   |    支持    |
  | Full-Text索引 |           （MySQL5.6+）支持            |    支持    |   不支持   |

- InnoDB在MySQL5.5后成为默认的存储引擎，B+Tree索引类型也是MySQL中的存储引擎支持最多的索引类型

### 按物理存储方式分类

- 按照物理存储的方式来看，索引分为聚簇索引（聚集索引/主键索引）、二级索引（辅助索引）
  - 主键索引的B+Tree的叶子节点存放的是实际数据（所有完整的用户记录）
  - 二级索引的B+Tree的叶子节点存放的是主键值（存储的并非是实际数据）

- 在建表时，InnoDB引擎会根据不同的场景选择不同的列作为索引：

  - 如果有主键，默认会使用**`主键`**作为**聚簇索引的索引键**
  - 如果没有主键，就选择**`第一个不包含NULL值的唯一列`**作为**聚簇索引的索引键**
  - 如果上面两个条件都不符合，InnoDB将自动生成一个**隐示id列作为聚簇索引的索引键**

- 创建的主键索引和二级索引默认使用的是B+Tree索引

- B+Tree是一种多叉树，**叶子节点才存放数据，非叶子节点只存放索引**，且每个节点中的数据是按主键顺序存储的，每层父节点的索引值都会出现在下层子节点的索引值中

  =》因此，**叶子节点中包含了所有的索引值信息**，且**每个叶子节点都有前驱指针和后继指针**，分别指向上一个和下一个叶子节点，如此以形成一个双向链表

主键索引的B+Tree示意图如下：

![image](https://github.com/user-attachments/assets/8801fbde-81bc-4ebb-b445-fd16f5a37dd1)


- 数据库的索引和数据都存储在硬盘中，可将读取一个节点算作一个磁盘I/O，如上的整个查询过程会经历三个节点（三次I/O操作）

  =》B+Tree存储千万级别的数据只需要3~4层高/千万级的表查询数据最多需要3~4次磁盘I/O

  =》B+Tree相较于B+树和二叉树来说，最大的优势在于查询效率高，即便数据量很大，查询数据的磁盘I/O仍然可维持在3~4次



- 主键索引的B+Tree的叶子节点存储的是完整的用户记录；二级索引的B+Tree的叶子节点存储的是主键值
- 二级索引的B+Tree示意图如下：

![image](https://github.com/user-attachments/assets/7a671287-2c36-4904-a5ee-74f73d6e69a8)


- 如果数据能在二级索引中能查询到数据所需的列，就不需要回表，该过程就被称为**覆盖索引**
  如果查询的数据不在二级索引中，会先查询二级索引，获取到对应叶子节点的主键值，再检索主键索引，查询到行数据所需要的列，该过程称为**回表**

### 按字段特性分类
- 从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引

#### 主键索引

- 主键索引，建立在主键字段上的索引，通常在创建表时一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值
- MySQL 中的**主键索引不支持降序排序**，因为主键的主要目的是**确保唯一性和快速的查找**，因而只**按照升序来构建**

- 在创建表时，创建主键索引的SQL如下：

  ```sql
  CREATE TABLE `example_table`(
    `id` INT(11) UNSIGNED NOT NULL,
    `column1` VARCHAR(50),
    `column2` VARCHAR(50),
    `column3` VARCHAR(50),
   PRIMARY KEY (`id`) USING BTREE
  );
  ```

- 建表后，如果要创建唯一索引，可使用如下命令：

  ```sql
  ALTER TABLE `example_table`
  ADD PRIMARY KEY (`id`);
  ```

  

#### 唯一索引

- 唯一索引，建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值

- 在创建表时，创建唯一索引的SQL示例如下：

  ```sql
  CREATE TABLE `example_table` (
      `id` INT(11) UNSIGNED NOT NULL,
      `column1` VARCHAR(50),
      `column2` VARCHAR(50),
      UNIQUE KEY `unique_index_column1` (`column1`)
  );
  ```

​       如上，`UNIQUE KEY `unique_index_column1` (`column1`)`建立的索引默认是按升序组织的，如果降序组织，需要在`column1`后                               面加上`DESC`，即`UNIQUE KEY `unique_index_column1` (`column1` DESC)`，同理，普通索引升序也是如此

- 建表后，如果要创建唯一索引，可使用如下命令（为column2、column3建立名为`uk_idx_col1_col2`的索引）：

  ```sql
  CREATE UNIQUE INDEX `uk_idx_col1_col2`
   ON `example_table`(`column2`,`column3`);
   
   # 或者
   ALTER TABLE `example_table`
  ADD UNIQUE `unique_index_column23` (`column2`,`column3`);
  ```



#### 普通索引

- 普通索引：建立在普通字段上的索引，**不要求字段为主键或字段值唯一**

- 在创建表时，创建普通索引的SQL示例如下：

  ```sql
  CREATE TABLE `example_table` (
      `id` INT AUTO_INCREMENT,
      `column1` VARCHAR(50),
      `column2` VARCHAR(50),
      KEY `normal_index_column2` (`column2` DESC)
  );
  ```

  如果要让普通索引不升序组织（改为降序），去掉DESC即可，

- 建表后，如果要创建普通索引，可使用如下SQL：

  ```sql
  ALTER TABLE `example_table`
  ADD INDEX `normal_index_column2` (`column2`);
  ```

  

#### 前缀索引

- 前缀索引：针对字符类型的前几个字符建立的索引，前缀索引可建立在字段类型为char、varchar、varbinary的列上

- 在创建表时，创建前缀索引的SQL示例如下：

  ```sql
   CREATE TABLE `example_table` (
      `id` INT(11) NOT NULL,
      `column1` VARCHAR(50),
      `column2` VARCHAR(50),
      KEY `prefix_index_column1` (`column1`(10))
  );
  ```

- 使用前缀索引的目的：减少索引占用的存储空间，提升查询效率

  如上，使用 `KEY `prefix_index_column1` (`column1`(10))` ，为 `column2` 的前 10 个字符创建了前缀索引。**前缀索引可以在文本列上使用，当列的长度较长时，使用前缀索引可以节省空间并提高性能**，但可能会导致索引选择性降低

- 建表后，如果要创建的索引，可使用如下SQL语句：

  ```sql
  ALTER TABLE `example_table`
  ADD INDEX `prefix_index_column2` (`column2`(10));
  ```

  


### 按字段个数分类
- 从字段个数的角度的来看，索引分为单列索引、联合索引（复合索引）
  - 建立在单个字段/列上的索引（比如主键索引），称为单列索引
  - 建立在多个字段/列上的索引，称为联合索引
  
- 比如：将商品表product中的product_no 和 name字段共同组合成联合/复合索引，创建联合索引的SQL如下：

  ```sql
  CREATE INDEX `idx_product_no_name` ON `product`(`product_no`,`name`);
  # 或
  ALTER TABLE `product`
  ADD INDEX `idx_product_no_name` (`product_no`,`name`);
  ```

- 使用联合索引时，遵循最左匹配原则，即按照最左优先的方式来进行索引的匹配，如果不遵循【最左匹配原则】，联合索引会失效，以致于无法利用索引完成快速查询

- 如果查询过程中使用了联合索引查询，可能存在部分字段使用到联合索引的B+Tree，而也有些字段没有用到联合索引的B+Tree的情况
=》这种特殊情况发生在范围查询，联合索引的最左匹配原则会一直向右匹配直至遇到【范围查询】就会停止匹配
 即**范围查询的字段可用到联合索引，但范围查询字段后面的字段无法用到联合索引**


## 创建索引的时机
- 使用索引最大的好处是提高查询速度，其缺点如下：
  - 需占用额外的物理空间，数量越大，占用空间越大
  - 创建和维护索引会增加耗时，且时间会随着数据量的增大而增大
  - 降低表的增删改查效率，因为每次增删改索引，B+树为维护索引的有序性，都需要动态维护

- 索引适用/不适用的场景
  适用：

  - 1）字段有唯一性限制
  - 2）**经常用于where查询条件**，能够提高整个表的查询速度，如果查询条件不是一个字段，则可以建立联合索引
  - 3）**经常用于`group by`和`order by`的字段**，**在查询时就不需要再去排序**了，因为建立索引后在B+Tree中的记录都是排序好的

  不适用：

  - **where条件中，group by，order by中使用不到的字段**，使用索引如果不能快速定位数据，则通常**不需要创建索引**，因为索引会占用物理空间
  - 针对存在大量重复数据（区分度不高）的字段，不需要创建索引，比如：性别，订单状态等字段  =》MySQL的查询优化器发现某个值在表中数据行的列上占比很高，则会忽略索引，进行全表扫描
  - 表数据太少时，不需要创建索引
  - **对于经常更新的字段不需要创建索引**，由于要维护B+树的有序性，字段频繁更新就需要频繁地重建索引，该过程会影响数据库性能

## 如何优化索引
常见的优化索引的方法如下：
- 1）前缀索引优化：使用前缀索引，是为了减少索引字段的大小，可增加一个索引页中存储的索引值，有效提高索引的查询速度
         前缀索引的局限性：1）order by 无法使用前缀索引  2）无法将前缀索引作为覆盖索引
     
- 2）覆盖索引优化：SQL中查询的所有字段，在索引B+Tree的叶子节点上都能找到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获取，可避免回表操作
   
   - 假设我们只需要查询商品的名称、价格，有什么方式可避免回表？
     可以建立一个联合索引，即【商品ID、名称、价格】作为一个联合索引，如果索引中存在这些数据，查询时就不会再次检索主键索引，如此以避免回表
     所以，使用覆盖索引的好处：不需要查询出包含整条行记录的所有信息，以减少大量的I/O操作
   
- 3）主键索引最好自增：   
   
   - 建表时默认将主键索引设置为自增的，好处如下：
     InnoDB创建主键索引时 默认使用聚簇索引，数据被存放在B+Tree的叶子节点上 
     =》 同一个叶子节点内的各行数据是按主键顺序存放的，因此，每当有一条数据插入时，数据库会根据主键将其插入对应的叶子节点中
   
   - 如果使用非自增主键，由于**每次插入主键的索引值都是随机**的（**每次插入新的数据时，可能会插入到现有数据页中间的某个位置**），这导致不得不移动其他数据来满足新数据的插入，甚至需要从一个页面复制数据到另一个页面，这种情况通常被称为页分裂
   
     ![image](https://github.com/user-attachments/assets/2e171605-ce95-4e27-92dc-94a1cd06cf53)

   
   - 此外，**页分裂还可能会造成大量的内存碎片**，导致索引结构不紧凑，从而影响查询效率
     =》 因此，在使用InnoDB存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键
      另外，主键字段不要过大，因为**主键字段长度越小，二级索引的叶子节点越小**（二级索引的叶子节点存储的数据为主键值），二级索引占用的空间就越小
   
- 4）索引尽可能设置为NOT NULL
    为更好地使用索引，索引列要设置为NOT NULL约束，原因如下：
    
    - 索引列存在NULL会导致优化器在选择索引时更加复杂，更难以优化，因为可为NULL的列会使索引、索引统计（count统计会省略为NULL的行记录）和值比较都更复杂
    - NULL值无意义，但仍会占用物理内存，会有存储空间的问题，因为InnoDB存储记录时，如果表中存在允许为NULL的字段，则行格式中至少会用1字节空间来存储NULL值列表
    
- 5）防止索引失效：
   通过执行计划，我们可判断查询语句是否使用了索引，对于执行计划，参数有：
   
     - possible_keys：表示可能用到的索引
     - key：表示实际使用的索引，如果该项为NULL，则说明没有使用索引
     - key_len：表示索引的长度
     - rows：表示扫描的数据行数
     - extra：查询语句的额外信息，常见的字段值如下：
        - Using filesort：当查询语句中包含group by，且无法使用索引完成排序操作时，就必须要使用相应的排序算法，甚至可能会通过文件排序，效率最低
        - Using temporary：使用了临时表保存中间的结果，MySQL对查询结果排序时会使用临时表，常见于order by排序和group by 分组查询，效率较低
        - Using index：使用到覆盖索引，所需的查询数据在索引中即可全部获取到，不需要再回表查询，效率较高
     - type：表示数据扫描类型，即查询到所需数据时使用的扫描类型，常见的扫描类型的执行效率，从低到高的顺序为：
         - All：全表扫描
         - index：全索引扫描
         - range：索引范围扫描
         - ref：非唯一索引扫描
         - eq_ref：唯一索引扫描
         - const：查询数据只有一条的主键或唯一索引扫描

## InnoDB为何选择B+Tree来实现索引

B+Tree相比于B树、二叉树或Hash索引结构的优势如下：

- B+Tree VS B树

  - B+Tree只在叶子节点存储数据，而B树的非叶子节点也要存储数据

    =》在相同的磁盘I/O次数下，能查询到更多的节点

  - B+Tree叶子节点采用双向链表连接，适合MySQL中范围内顺序查询，而B树的叶子节点之间没有连接，如要进行范围查询，复杂度较高

- B+Tree VS 二叉树

  - 对于有N个叶子节点的B+Tree，其搜索复杂度为O(logdN)，其中d表示父节点允许拥有子节点的最大个数

  - 在实际应用中，d值通常会大于100，如此，即便数据达到千万级别，B+Tree的高度依然可维持在3~4层

    =》一次查询操作只需要3~4次的磁盘I/O就能查询到目标数据

  - 二叉树中每个父节点的子节点个数最多是两个，在存储相同数据量的情况下，树的高度会比B+Tree高出不少

    =》**二叉树检索到目标数据所经历的磁盘I/O次数要更多**

- B+Tree VS Hash

  - Hash在做等值查询时效率巨高，查询复杂度为O(1)，但不适合范围查询

    =》使用B+Tree比使用Hash来构建索引有着更广泛的适用场景
