# 运行时数据区域

- Java虚拟机在执行Java程序的过程中，会将管理的内存划分成若干个不同的数据区域

- 这里以JDK1.7和JDK1.8两个版本为例来介绍：

  JDK1.7：

![image](https://github.com/user-attachments/assets/0da30f2a-04ba-4f25-8053-ea9a64bb6f01)


JDK1.8：

![image](https://github.com/user-attachments/assets/76929260-4991-464f-be1f-6743326a8743)


## 线程私有

- 为方便线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为"线程私有"的内存

### 程序计数器

- 程序计数器是一块较小的内存空间，可看作是**当前线程所执行字节码**的**行号指示器**，字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、分支选择、循环或异常处理
- 在多线程环境下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来时能知道该线程上次运行到的位置
- 程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域，其生命周期会随线程的创建而创建，随线程结束而销毁

### 本地方法栈

- 本地方法栈**为虚拟机使用的`native`方法服务**，在本地方法执行时，本地方法栈会创建一个**栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息**
- 方法执行完毕后，相应的栈帧会出栈并释放内存空间，也会出现`StackOverFlowError`和`OutOfMemoryError`

### Java虚拟机栈

- Java虚拟机栈与程序计数器、本地方法栈一样，Java虚拟机栈也是线程私有的，其生命周期和线程相同，随线程创建而创建，随线程结束而消亡

- 除了`native`方法的调用是通过本地方法栈实现的，其他所有的Java方法调用都是通过栈来实现的（需要和其他运行时数据区相配合）

- 方法调用的数据需要通过栈来传递，每次方法调用都有一个对应的栈帧被压入栈中，每个方法调用结束后，都会有一个栈帧被弹出

- 栈由一个个栈帧组成，每个栈帧中都有：局部变量表、操作数栈、动态链接、方法返回地址

  ![image](https://github.com/user-attachments/assets/d11c61b9-4534-47d4-96d8-c4ce2661f419)



#### 局部变量表

- 局部变量表：主要存放了编译期间可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（不同于对象本身，reference类型可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）



#### 操作数栈

- 操作数栈：主要作为方法调用的中转站使用，用于存放执行过程中产生的中间计算结果，另外，计算过程中产生的临时变量也会放在操作数栈中

#### 动态链接

- 动态链接：主要服务一个方法需要调用其他方法的场景，Class文件的常量池中保存有大量的符号引用（如：方法的符号引用）

  当一个方法需要调用其他方法，需要将常量池中指向方法的符号引用转化为在内存地址中的直接引用，即将符号引用转化为调用方的直接引用

  ![image](https://github.com/user-attachments/assets/d5632e0d-8b29-4fcb-bad7-667261fc1770)

  
- 如果函数调用陷入无限循环，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深

  且栈的内存不允许动态扩展，当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，就抛出`StackOverFlowError`

- 如果栈的内存大小可动态扩展，且虚拟机在动态扩展栈时无法申请到足够的内存空间，则会抛出`OutOfMemoryError`异常

- Java方法有抛出异常和return语句正常返回两种返回方式，不管哪种返回方式，都会导致栈帧被弹出

  =》栈帧会随方法调用而创建，随方法结束而销毁，无论方法正常完成还是异常完成都算作方法结束



## 线程共享

### 堆

- 堆是Java虚拟机所管理的最大一块内存空间，被所有线程共享，在虚拟机启动时创建

- Java堆的唯一目的是存放对象实例，几乎所有的对象实例以及数组都在Java堆分配内存

- 从JDK1.7开始默认开启逃逸分析，如果某些方法中的对象引用没有被返回或未被外界使用（即未逃逸出去），则对象可以直接在栈上分配内存

- Java堆是垃圾收集器管理的主要区域，也被称为GC堆（Garbage Collected Heap），从垃圾回收的角度来看，由于收集器基本都采用分代收集算法，Java堆可细分为新生代和老年代，以便更好地回收内存，或更快地分配内存

- 在JDK1.7及以前，堆内存通常被分为以下三部分：

  1）新生代内存（Young Generation）

  2）老年代内存（Old Generation）

  3）永久代（Permanent Generation）

  
![image](https://github.com/user-attachments/assets/dd918f45-6fd6-412c-af6f-eb3e222ed9d7)


- 如上图所示，Eden区、Survivor区s0和s1都属于新生代，Tenured属于老年代，Permanent Generation属于永久代
- JDK8版本之后，永久代已被Metaspace（元空间）取代，元空间使用的是本地内存

### 方法区

- 方法区属于JVM运行时数据区域的一块逻辑区域，是各个线程共享的内存区域

- 在《Java虚拟机规范》中，只是规定了有方法区的概念和作用，方法区到底要如何实现由虚拟机自行决定，即在不同的虚拟机实现上，方法区的实现是不同的

- 当虚拟机要使用一个类时，虚拟机需要读取并解析Class文件获取相关的信息，并将信息存入到方法区，**方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器后的代码缓存**等数据

- 方法区和永久代以及元空间的关系：永久代以及元空间是HotSpot虚拟机对虚拟机规范中方法区的两种实现，且永久代是JDK1.8之前的方法区实现，元空间是JDK1.8及之后的实现

  

- 永久代为什么要替换为元空间（MetaSpace）？

  - 1）整个永久代有一个JVM本身设置的固定大小上限，无法进行调整（即受到JVM内存的限制），而元空间使用的是本地内存，会受到本机可用内存的影响，虽然元空间仍旧可能会内存溢出，但会比原来出现溢出的概率小很多

    `-XX:MaxMetaspaceSize`设置最大元空间的大小，默认值为unlimited，即只会受到系统内存的限制

    `-XX:MetaspaceSize`定义元空间的初始大小，如果未指定此标志，则Metaspace将根据运行时的应用程序动态地重新调整大小

  - 2）元空间中存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，以便于能加载更多的类

  - 3）永久代会为GC带来不必要的复杂度，且回收效率偏低

- 方法区常用参数有哪些？

  - JDK1.8之前永久代还没被彻底移除时通常会通过如下参数来调节方法区的大小：

  ```shell
  -XX:PermSize=N     // 方法区（永久代）初始大小
  -XX:MaxPermSize=N  // 方法区（永久代）最大大小，超过该值将会抛出OutOfMemoryError异常: java.lang.OutOfMemoryError: PermGen
  ```

  - 相对而言，垃圾收集行为在这个区域是比较少见的，但并非数据进入方法区后就"永久存在"了
  - JDK1.8时，方法区被彻底移除了，取而代之的是元空间，元空间使用的是本地内存，如下是一些常用参数：

  ```shell
  -XX:MetaspaceSize=N     // 设置Metaspace的初始大小和最大大小
  -XX:MaxMetaspaceSize=N  // 设置Metaspace的最大大小
  ```

  - 和永久代很大的不同的是，如果不指定方法区的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存

### 运行时常量池

- **Class文件**中除了有类的版本、字段、方法、接口等描述信息外，还有**用于存放编译期生成的各种字面量和符号引用的常量池表**
- 字面量是源代码中的固定值的表示方法，字面量包括整数、浮点数和字符串字面量，常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号



### 字符串常量池

- 字符串常量池：JVM为提升性能和**减少内存消耗**，针对字符串（String类）专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**（即字符串常量池中的字符串是唯一的，不会重复存储）

  - 通过字面量（如 `String s = "hello";`）创建的字符串会自动放入常量池
  - 通过 `new String("hello")` 创建的字符串对象不会放入常量池，而是存储在堆内存中

- HotSpot虚拟机中字符串常量池的实现`stringTable.cpp`，`StringTable`可简单理解为一个固定大小的HashTable，容量为StringTableSize（可通过`-XX:StringTableSize`参数设置），保存的是字符串和字符串对象的引用的映射关系，字符串对象的引用指向堆中的字符串对象

- JDK1.7之前，字符串常量池存放在永久代，JDK1.7字符串常量池和静态变量从永久代移动到了Java堆中

![image](https://github.com/user-attachments/assets/c8430e76-bf7c-4a67-a3a0-e4638396bf32)
![image](https://github.com/user-attachments/assets/ad86ac19-7413-4357-b262-a91dc9621862)


JDK1.7为什么要将字符串常量池移到堆中？

- 因为永久代的GC效率太低，只有在整堆收集（Full GC）时才会被执行GC
- Java程序中通常会有大量被创建的字符串等待回收，将字符串常量池移到堆中，可高效及时地回收字符串

#### String.intern()

- String.intern()：检查字符串常量池中是否存在与当前字符串内容相同的字符串，并返回字符串在常量池中的引用
  - 如果存在，则返回常量池中的字符串引用
  - 如果不存在，则将当前字符串添加到常量池中，并返回常量池中的引用

- 应用场景：

  - **减少内存占用**：当程序中有大量重复字符串时，使用 `intern()` 可以将这些字符串指向常量池中的同一对象，从而节省内存
  - **字符串比较优化**：通过 `intern()` 方法，可以使用 `==` 来比较字符串内容，而不必使用 `equals()` 方法

- 代码示例：

  ```java
          // 通过字面量创建字符串，自动放入常量池
          String s1 = "hello";
          String s2 = "hello";
  
          // 通过 new 创建字符串，存储在堆内存中
          String s3 = new String("hello");
          String s4 = new String("hello");
  
          // 使用 intern() 方法将字符串放入常量池
          String s5 = s3.intern();
  
          // 比较字符串引用
          System.out.println(s1 == s2); // true,都指向常量池中的同一对象
          System.out.println(s1 == s3); // false,s3 是堆内存中的对象
          System.out.println(s1 == s5); // true,s5 是常量池中的对象
          System.out.println(s3 == s4); // false,s3 和 s4 是不同的堆内存对象
  
          // 使用 equals 比较字符串内容
          System.out.println(s1.equals(s3)); // true,内容相同
  ```

  

### 直接内存

- 直接内存是一种特殊的内存缓冲区，并不在Java堆或方法区中分配，而是通过JNI的方式在本地内存上分配，即**直接内存的分配不会受到Java堆的限制**，但会受到**本机总内存大小以及处理器寻址空间的限制**
- 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但这部分内存也会被频繁地使用，也还可能导致`OutOfMemoryError`出现
- JDK1.4中新加入的NIO（NIO-Blocking I/O，也被称为New I/O），是一种**基于通道（Channel）和缓存区（Buffer）的I/O方式**，可直接**使用native函数库直接分配堆外内存**，再通过一个**存储在Java堆中的DirectByteBuffer对象来作为这块内存的引用进行操作**，如此以提高在某些场景中的性能，避免了在Java堆和Native堆之间来回复制数据

  参考：
  - https://javaguide.cn/java/jvm/memory-area.html







