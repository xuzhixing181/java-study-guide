# 运行时数据区域

- Java虚拟机在执行Java程序的过程中，会将管理的内存划分成若干个不同的数据区域

- 这里以JDK1.7和JDK1.8两个版本为例来介绍：

  JDK1.7：

![image](https://github.com/user-attachments/assets/0da30f2a-04ba-4f25-8053-ea9a64bb6f01)


JDK1.8：

![image](https://github.com/user-attachments/assets/76929260-4991-464f-be1f-6743326a8743)


## 线程私有

- 为方便线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为"线程私有"的内存

### 程序计数器

- 程序计数器是一块较小的内存空间，可看作是**当前线程所执行字节码**的**行号指示器**，字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、分支选择、循环或异常处理
- 在多线程环境下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来时能知道该线程上次运行到的位置
- 程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域，其生命周期会随线程的创建而创建，随线程结束而销毁

### 本地方法栈

- 本地方法栈**为虚拟机使用的`native`方法服务**，在本地方法执行时，本地方法栈会创建一个**栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息**
- 方法执行完毕后，相应的栈帧会出栈并释放内存空间，也会出现`StackOverFlowError`和`OutOfMemoryError`

### Java虚拟机栈

- Java虚拟机栈与程序计数器、本地方法栈一样，Java虚拟机栈也是线程私有的，其生命周期和线程相同，随线程创建而创建，随线程结束而消亡

- 除了`native`方法的调用是通过本地方法栈实现的，其他所有的Java方法调用都是通过栈来实现的（需要和其他运行时数据区相配合）

- 方法调用的数据需要通过栈来传递，每次方法调用都有一个对应的栈帧被压入栈中，每个方法调用结束后，都会有一个栈帧被弹出

- 栈由一个个栈帧组成，每个栈帧中都有：局部变量表、操作数栈、动态链接、方法返回地址

  ![image](https://github.com/user-attachments/assets/d11c61b9-4534-47d4-96d8-c4ce2661f419)



#### 局部变量表

- 局部变量表：主要存放了编译期间可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（不同于对象本身，reference类型可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）



#### 操作数栈

- 操作数栈：主要作为方法调用的中转站使用，用于存放执行过程中产生的中间计算结果，另外，计算过程中产生的临时变量也会放在操作数栈中

#### 动态链接

- 动态链接：主要服务一个方法需要调用其他方法的场景，Class文件的常量池中保存有大量的符号引用（如：方法的符号引用）

  当一个方法需要调用其他方法，需要将常量池中指向方法的符号引用转化为在内存地址中的直接引用，即将符号引用转化为调用方的直接引用

  ![image](https://github.com/user-attachments/assets/d5632e0d-8b29-4fcb-bad7-667261fc1770)

- 如果函数调用陷入无限循环，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深

  且栈的内存不允许动态扩展，当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，就抛出`StackOverFlowError`

- 如果栈的内存大小可动态扩展，且虚拟机在动态扩展栈时无法申请到足够的内存空间，则会抛出`OutOfMemoryError`异常

- Java方法有抛出异常和return语句正常返回两种返回方式，不管哪种返回方式，都会导致栈帧被弹出

  =》栈帧会随方法调用而创建，随方法结束而销毁，无论方法正常完成还是异常完成都算作方法结束



## 线程共享

### 堆

- 堆是Java虚拟机所管理的最大一块内存空间，被所有线程共享，在虚拟机启动时创建

- Java堆的唯一目的是存放对象实例，几乎所有的对象实例以及数组都在Java堆分配内存

- 从JDK1.7开始默认开启逃逸分析，如果某些方法中的对象引用没有被返回或未被外界使用（即未逃逸出去），则对象可以直接在栈上分配内存

- Java堆是垃圾收集器管理的主要区域，也被称为GC堆（Garbage Collected Heap），从垃圾回收的角度来看，由于收集器基本都采用分代收集算法，Java堆可细分为新生代和老年代，以便更好地回收内存，或更快地分配内存

- 在JDK1.7及以前，堆内存通常被分为以下三部分：

  1）新生代内存（Young Generation）

  2）老年代内存（Old Generation）

  3）永久代（Permanent Generation）

  

![image](https://github.com/user-attachments/assets/dd918f45-6fd6-412c-af6f-eb3e222ed9d7)


- 如上图所示，Eden区、Survivor区s0和s1都属于新生代，Tenured属于老年代，Permanent Generation属于永久代
- JDK8版本之后，永久代已被Metaspace（元空间）取代，元空间使用的是本地内存

### 方法区

- 方法区属于JVM运行时数据区域的一块逻辑区域，是各个线程共享的内存区域

- 在《Java虚拟机规范》中，只是规定了有方法区的概念和作用，方法区到底要如何实现由虚拟机自行决定，即在不同的虚拟机实现上，方法区的实现是不同的

- 当虚拟机要使用一个类时，虚拟机需要读取并解析Class文件获取相关的信息，并将信息存入到方法区，**方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器后的代码缓存**等数据

- 方法区和永久代以及元空间的关系：永久代以及元空间是HotSpot虚拟机对虚拟机规范中方法区的两种实现，且永久代是JDK1.8之前的方法区实现，元空间是JDK1.8及之后的实现

  

- 永久代为什么要替换为元空间（MetaSpace）？

  - 1）整个永久代有一个JVM本身设置的固定大小上限，无法进行调整（即受到JVM内存的限制），而元空间使用的是本地内存，会受到本机可用内存的影响，虽然元空间仍旧可能会内存溢出，但会比原来出现溢出的概率小很多

    `-XX:MaxMetaspaceSize`设置最大元空间的大小，默认值为unlimited，即只会受到系统内存的限制

    `-XX:MetaspaceSize`定义元空间的初始大小，如果未指定此标志，则Metaspace将根据运行时的应用程序动态地重新调整大小

  - 2）元空间中存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，以便于能加载更多的类

  - 3）永久代会为GC带来不必要的复杂度，且回收效率偏低

- 方法区常用参数有哪些？

  - JDK1.8之前永久代还没被彻底移除时通常会通过如下参数来调节方法区的大小：

  ```shell
  -XX:PermSize=N     // 方法区（永久代）初始大小
  -XX:MaxPermSize=N  // 方法区（永久代）最大大小，超过该值将会抛出OutOfMemoryError异常: java.lang.OutOfMemoryError: PermGen
  ```

  - 相对而言，垃圾收集行为在这个区域是比较少见的，但并非数据进入方法区后就"永久存在"了
  - JDK1.8时，方法区被彻底移除了，取而代之的是元空间，元空间使用的是本地内存，如下是一些常用参数：

  ```shell
  -XX:MetaspaceSize=N     // 设置Metaspace的初始大小和最大大小
  -XX:MaxMetaspaceSize=N  // 设置Metaspace的最大大小
  ```

  - 和永久代很大的不同的是，如果不指定方法区的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存

### 运行时常量池

- **Class文件**中除了有类的版本、字段、方法、接口等描述信息外，还有**用于存放编译期生成的各种字面量和符号引用的常量池表**
- 字面量是源代码中的固定值的表示方法，字面量包括整数、浮点数和字符串字面量，常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号



### 字符串常量池

- 字符串常量池：JVM为提升性能和**减少内存消耗**，针对字符串（String类）专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**（即字符串常量池中的字符串是唯一的，不会重复存储）

  - 通过字面量（如 `String s = "hello";`）创建的字符串会自动放入常量池
  - 通过 `new String("hello")` 创建的字符串对象不会放入常量池，而是存储在堆内存中

- HotSpot虚拟机中字符串常量池的实现`stringTable.cpp`，`StringTable`可简单理解为一个固定大小的HashTable，容量为StringTableSize（可通过`-XX:StringTableSize`参数设置），保存的是字符串和字符串对象的引用的映射关系，字符串对象的引用指向堆中的字符串对象

- JDK1.7之前，字符串常量池存放在永久代，JDK1.7字符串常量池和静态变量从永久代移动到了Java堆中

![image](https://github.com/user-attachments/assets/c8430e76-bf7c-4a67-a3a0-e4638396bf32)
![image](https://github.com/user-attachments/assets/ad86ac19-7413-4357-b262-a91dc9621862)


JDK1.7为什么要将字符串常量池移到堆中？

- 因为永久代的GC效率太低，只有在整堆收集（Full GC）时才会被执行GC
- Java程序中通常会有大量被创建的字符串等待回收，将字符串常量池移到堆中，可高效及时地回收字符串

#### String.intern()

- String.intern()：检查字符串常量池中是否存在与当前字符串内容相同的字符串，并返回字符串在常量池中的引用
  - 如果存在，则返回常量池中的字符串引用
  - 如果不存在，则将当前字符串添加到常量池中，并返回常量池中的引用

- 应用场景：

  - **减少内存占用**：当程序中有大量重复字符串时，使用 `intern()` 可以将这些字符串指向常量池中的同一对象，从而节省内存
  - **字符串比较优化**：通过 `intern()` 方法，可以使用 `==` 来比较字符串内容，而不必使用 `equals()` 方法

- 代码示例：

  ```java
          // 通过字面量创建字符串，自动放入常量池
          String s1 = "hello";
          String s2 = "hello";
  
          // 通过 new 创建字符串，存储在堆内存中
          String s3 = new String("hello");
          String s4 = new String("hello");
  
          // 使用 intern() 方法将字符串放入常量池
          String s5 = s3.intern();
  
          // 比较字符串引用
          System.out.println(s1 == s2); // true,都指向常量池中的同一对象
          System.out.println(s1 == s3); // false,s3 是堆内存中的对象
          System.out.println(s1 == s5); // true,s5 是常量池中的对象
          System.out.println(s3 == s4); // false,s3 和 s4 是不同的堆内存对象
  
          // 使用 equals 比较字符串内容
          System.out.println(s1.equals(s3)); // true,内容相同
  ```

  

### 直接内存

- 直接内存是一种特殊的内存缓冲区，并不在Java堆或方法区中分配，而是通过JNI的方式在本地内存上分配，即**直接内存的分配不会受到Java堆的限制**，但会受到**本机总内存大小以及处理器寻址空间的限制**

- 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但这部分内存也会被频繁地使用，也还可能导致`OutOfMemoryError`出现

- JDK1.4中新加入的NIO（NIO-Blocking I/O，也被称为New I/O），是一种**基于通道（Channel）和缓存区（Buffer）的I/O方式**，可直接**使用native函数库直接分配堆外内存**，再通过一个**存储在Java堆中的DirectByteBuffer对象来作为这块内存的引用进行操作**，如此以提高在某些场景中的性能，避免了在Java堆和Native堆之间来回复制数据

  

## HotSpot虚拟机对象

### 对象的创建

#### 1）类加载检查

- 虚拟机遇到一条new指令时，会先去检查该指令的参数是否能在常量池中定位到该类的符号引用，且检查该符号引用所代表的类是否已被加载过、解析和初始化过，如果没有，就必须先执行相应类的加载

#### 2）分配内存

- 在类加载检查通过后，虚拟机将为新生对象分配内存，对象所需的内存大小在类加载完成后便可确定，为对象分配内存即是将一块大小确定的内存从Java堆中划分出来
- 分配方式有`指针碰撞`和`空闲列表`两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定（即垃圾收集器采用的收集算法是`标记-清除`还是`标记-整理`/`标记-压缩`）
  - 指针碰撞：适用于堆内存规整（没有内存碎片）的情况下
    - 实现：用过的内存全部整合到一边，没有用过的内存放在另一边，中间通过分界指针，向着没用过的内存方向，将该指针移动对象内存位置即可
    - 使用该分配方式的GC收集器：Serial、ParNew等
  - 空闲列表：适用于堆内存不规整的情况下
    - 实现：虚拟机维护一个列表，该列表会记录哪些内存块是可用的，在分配内存时，找一块足够大的内存块来划分给对象实例，最后再更新列表记录
    - 使用该分配方式的GC收集器：CMS等

**内存分配并发问题**

- 实际开发过程中，创建对象会很频繁，

- 在多线程环境下，多个线程同时从堆内存中分配对象时，可能会竞争同块内存区域而出现线程安全问题，JVM通过`CAS+失败重试`和`TLAB`两种方式来保证线程安全：

  - `CAS+失败重试`：CAS是乐观锁的一种实现方式，每次不加锁，假设没有冲突而去完成某项操作，如果有冲突，则失败后重试，直至成功；虚拟机采用CAS+失败重试的方式来保证更新操作的原子性

  - `TLAB`：为每个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存用尽时，再使用CAS来分配内存

    补充：

    - TLAB（hread-Local Allocation Buffer）是Java虚拟机中用于提升对象分配性能的一种机制，其主要目的是减少多线程环境下对象分配的锁竞争，从而提高内存分配的效率
    - JVM为每个线程分配一块私有的内存区域（TLAB），线程在分配对象时优先使用自己的TLAB，以避免竞争

#### 3）初始化零值

- **内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值**（不包括对象头），以保证对象的实例字段在Java代码中可不赋初始值就可直接使用，程序能访问到这些字段的数据类型所对应的零值

#### 4）设置对象头

- 初始化零值完成后，虚拟机要为对象进行必要的设置，如：该对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头中
- 根据虚拟机当前运行状态的不同（如是否启用偏向锁等），对象头会有不同的设置

#### 5）执行init方法

- 如上，从虚拟机的视角来看，一个新的对象已被创建，但从Java程序的视角来看，`init`方法还没执行，所有的字段都还是零值，一般来讲，执行new指令后才会执行`init`方法，完成对象的初始化，如此，一个真正可用的对象才算完全被创建出来

### 对象的内存布局

- 在HotSpot虚拟机中，对象在内存中的布局可分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）
- 对象头包括两部分信息：
  - 1）**标记字段（Mark Word）**：**存储对象自身的运行时数据**，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
  - 2）**类型指针（Klass pointer）**：对象指向其类元数据的指针，**虚拟机通过该指针来确定该对象是哪个类的实例**

- 实例数据：对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容
- **对齐填充**：仅起到**占位作用**，没什么特别含义，也并不一定存在，Hotspot虚拟机的自动内存管理要求对象的起始地址必须是8字节的整数倍，即**对象的大小必须是8字节的整数倍**
  对象头部分正好是8字节的整数倍，因此，**当对象实例数据部分没有对齐时，就需要通过对齐填充部分来补全**

### **对象的访问定位**

- 对象的访问方式由虚拟机的实现而定，主流的访问方式有：句柄和直接指针

- 句柄访问：Java堆中将会划分出一块内存来作为句柄池，reference中存储对象的句柄地址，而句柄中包含对象的实例数据和对象类型数据各自的具体地址信息

  ![image](https://github.com/user-attachments/assets/56223699-030e-4c85-be9e-2c75b093c011)
  

  - 应用场景：适用于**对象移动较频繁的场景**（如使用标记-整理算法的垃圾收集器），可降低对象移动时对引用变量的维护成本

  - 优点：
    1）对象移动灵活性高：当垃圾收集器整理堆内存时，可能会移动对象的位置，由于使用句柄访问对象，只需要**修改句柄中指向对象实例数据的指针**，而引用变量本身不需要改变，以减少引用变量的维护成本，提高对象移动的灵活性
    2）访问类型信息方便：句柄中包含了指向**对象类型数据的指针**，使得在**访问对象**的同时方便地**获取对象所属类的类型信息**，便于**实现反射、动态代理等高级特性**
  - 缺点：
    1）访问效率相对较低：相比于直接指针访问，通过句柄访问对象需要经过额外的中间步骤，即先通过引用变量找到句柄，再从句柄中获取到对象的实际地址，这会增加一定的访问开销，降低访问频率
    2）占用额外内存：需要在堆中专门划分一块区域来作为句柄池使用，用于存储句柄信息，这会额外地占用内存空间

- 直接指针：如果使用直接指针访问，reference中直接存储对象的地址

  ![image](https://github.com/user-attachments/assets/cfce347a-27e3-47b4-8f38-f5fe18ffe52c)


  - 应用场景：适用于**对性能要求高、对象移动较少的场景**（如大多数的Java程序、Hotspot虚拟机默认使用的就是直接指针访问）

  - 优点：访问效率高，无需经过句柄，引用变量直接指向对象的实际内存地址，对象的访问速度更快，减少了额外的指针查找操作，性能较高

  - 缺点：对象移动维护成本高，当垃圾收集器移动对象位置时，需要**修改所有引用该对象的引用变量的值**，因为**引用变量直接存储对象的实际地址**，如果引用变量较多，其维护工作会比较复杂，容易出错

    

参考：
- [Java内存区域详解（重点） | JavaGuide](https://javaguide.cn/java/jvm/memory-area.html)
- [Java虚拟机面试题 | 小林coding](https://xiaolincoding.com/interview/jvm.html)







