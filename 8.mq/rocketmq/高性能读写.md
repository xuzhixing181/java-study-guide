# 零拷贝技术

- 为防止进程崩溃后消息丢失，消息队列中的消息一般会放在磁盘而非内存中

- 消息从消息队列的磁盘发送到消费者，如果采用传统的IO方式，就会涉及到同一份数据来回拷贝的情况，效率较低，

  RocketMQ使用零拷贝技术中的`mmap`，Kafka使用零拷贝技术中的`sendfile`来实现消息的发送

## 传统IO方式

- 操作系统分为用户空间和内核空间，用户程序处于用户空间，而操作系统是程序和磁盘（硬件设备）之间的中间层，程序需要通过操作系统来调用硬件能力

- 如果用户程序想要将数据从磁盘发送到网络，要经历如下步骤：

  程序发起**`read()`系统调用**，尝试读取磁盘数据：

  - 数据从磁盘**拷贝**内核缓冲区
  - 再从内核缓冲区**拷贝**到用户空间

  程序发起**`write()`系统调用**，尝试将读取到的数据发送到网络：

  - 数据会从用户空间**拷贝**到Socket缓冲区
  - 再从Socket缓冲区**拷贝**到网卡

  最后，数据会经由网络达到消费者

![image-20250209121548132](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20250209121548132.png)

- 整个过程会发生`read()`和`write()`共两次系统调用，四次用户空间和内核空间的上下文切换，四次数据拷贝，效率较低，可采用零拷贝技术（`mmap`或`sendfile`）进行优化

## mmap

- `mmap`是操作系统内核提供的系统调用，用于将内核空间的缓冲区映射到用户空间

- 基于`mmap`发送消息的流程如下：

  程序发起`mmap()`系统调用，尝试读取磁盘数据：

  - 数据从磁盘**拷贝**到内核缓冲区
  - 内核缓冲区映射到用户空间（该操作不需要CPU拷贝）

  程序再发起`write()`系统调用，将读取到的数据发送到网络：

  - 数据从内核缓冲区**拷贝**到Socket缓冲区
  - 再从Socket缓冲区**拷贝**到网卡

![image-20250209133446286](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20250209133446286.png)

- 整个过程发生了`mmap()`和`write()`共两次系统调用，四次用户空间和内核空间的切换，三次数据拷贝，对比传统的IO方式，减少了一次用户空间和内核空间的拷贝
- `mmap`作为零拷贝技术的一种具体实现，指的是**数据从用户空间到内核空间不需要拷贝**，并非是指数据从磁盘发送到网卡的过程不需要拷贝

## sendfile

- `sendfile`也是操作系统内核提供的调用函数，用于发送文件数据

- 程序发起`sendfile()`系统调用，尝试从磁盘读取数据后发送到网卡，其步骤如下：

  - 数据从磁盘**拷贝**内核缓冲区

  - 再从内核缓冲区**直接拷贝**到网卡

    ![image-20250209135400567](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20250209135400567.png)

- 整个过程会发生一次系统调用，两次用户空间和内核空间的切换，两次数据拷贝

- `sendfile`中的零拷贝指的是零CPU拷贝，即不需要CPU参与（不耽误CPU执行程序），而是由其他硬件设备来完成数据的拷贝操作



## 为什么RocketMQ性能不如Kafka

- RocketMQ使用的零拷贝实现是`mmap`，而Kafka使用的零拷贝实现是`sendfile`，Kafka以更少的拷贝次数和系统内核切换次数获得了更好的性能

- **`mmap`函数返回数据的具体内容**，应用层能获取到消息内容并进行逻辑处理；**`sendfile`函数返回成功发送的字节数，应用层无法获知具体发送的消息内容**

  ```c
  void *mmap(void *addr, size_t length, int prot, int flags,
             int fd, off_t offset);
  // buf = mmap(xxx)
  
  
  ssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);
  // num = sendfile(xxx);
  ```

- RocketMQ的某些功能需要获取到具体的消息内容，以便于再次投递或根据消息内容进行对应的逻辑处理，如将消费失败的消息重新投递到死信队列中；如发送消息的动作会随事务成功提交而发送，随事务回滚而撤销

- Kafka只是追求极致性能，不需要有这些功能特性，因此而使用`sendfile`

  