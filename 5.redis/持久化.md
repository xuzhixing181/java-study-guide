- Redis为保证数据不丢失，提供了【RDB快照】和【AOF日志】两种持久化方式
- RDB快照文件记录的是二进制的键值对数据，AOF日志文件记录的是Redis操作命令

# RDB快照

## save和bgsave

- RDB文件的加载工作是在服务器启动时自动执行的，而没有提供加载RDB的命令

- Redis提供了`save`和`bgsave`两种命令来生成RDB文件，其区别在于是否【在主线程执行】

  - 行`save`命令，就会在主线程生成RDB文件（和执行操作命令在同一个线程），如果写入RDB文件时间过长，会阻塞主线程
  - 执行`bgsave`命令，会创建一个子进程来生成RDB文件，以避免阻塞主线程

- Redis可通过`redis.conf`配置文件来实现每隔一段时间自动执行一次bgsave命令，默认会提供如下配置：

  ```shel
  save 900 1
  save 300 10
  save 60 10000
  ```

  只要满足如上配置的其中一个条件，就会执行bgsave命令，其意思为分别900秒、300秒、60秒之内，对数据库分别进行了至少1、10、10000次修改，就会【创建子进程来生成RDB快照文件】

## 原理探究

### bgsave实现结构

- 服务器save选项所设置的保存条件，被封装在saveparam结构体中

```c
struct redisServer {
    // ...
    struct saveparam *saveparams;
    // ...
    long long dirty;
    time_t lastsave;   
}
```

- saveparams：一个数组，数组中的每个元素都是一个都保存了一个save选项设置的保存条件（修改时间段的毫秒数，修改次数）
- dirty：自上次save或bgsave操作后，对服务器【所有数据库状态】进行【增删改的操作次数】，即成功执行了多少次修改数据库的操作，dirty计数器的值就增加多少（save或bgsave命令执行完成后，dirty计数器会重置为0）
- lasttime：UNIX时间戳，记录服务器 上次成功执行save或bgsave操作的时间戳（）

```C
struct saveparams{
    // 秒数
    time_t seconds;
    // 修改次数
    int changes;
}
```

```she
save seconds changes: 即服务器在seconds秒内,对数据库至少进行了changes次修改
```

### 检查保存条件是否满足

- Redis服务器的周期性操作函数serverCron默认每隔100毫秒执行一次，该函数会维护正在运行的服务器，其中一项工作即是检查save选项所设置的保存条件是否满足，如果满足，就执行bgsave命令

- serverCron函数检查保存条件的过程：

  1）遍历save设置的所有保存条件，计算**距离上次执行保存操作**有多少秒

  2）如果数据库状态的修改次数超过条件所设置的次数，且距离上次保存的时间超过条件所设置的时间，则执行bgsave操作

  只要有任意一个save条件被满足，就会执行bgsave操作

### RDB文件结构

- RDB文件包含内容如下（全大写单词标识常量，全小写单词标识变量和数据）：

![image-20241211211221113](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241211211221113.png)

- REDIS常量：RDB文件最开头的五个字符，程序以此在载入文件时，快速检查所载入文件是否为RDB文件
- db_version：字符串表示的整数，记录了RDB文件的版本号
- databases：包含零个或任意多个数据库，以及各个数据库中的任意键值对数据，database N：代表N号数据库中的所有键值对数据
- EOF常量：标识RDB文件正文内容的结束，当读入程序遇到该值，则所有数据库的所有键值对数据都已载入完毕
- check_sum：一个8字节长的无符号整数，由前面四个部分计算得出；服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum比较，以此来检查RDB文件是否存在出错或损坏的情况

## 存在问题

- RDB快照是全量快照，即每次执行快照，都会将内存中的【所有数据】都记录到磁盘中

  =》执行快照的操作较重，如果太过频繁，会影响Redis的性能；如果频率太低，服务器故障时，会丢失较多数据

- RDB是全量快照，执行频率不能太过频繁；而AOF是以秒级的频率来记录操作命令，丢失的数据会相对更少

  

## 执行快照时如何修改数据

- 执行bgsave的操作会交给子进程来生成RDB文件，主线程还可以继续工作，如何修改数据？

  =》实现的关键在于【写时复制技术(Copy-On-Write，COW)】

- 执行bgsave命令时，会通过`fork()`创建子进程，此时子进程和父进程共享同一内存数据

  =》创建子进程时，会复制父进程的页表，但页表指向的物理内存还是一个

  ​      只有在发生内存数据修改时，物理内存才会被复制一份

![image-20241210214703775](D:\study-code\java-study-guide\5.redis\images\写时复制技术图1.png)

- 由于创建子进程会阻塞主线程，而使用【写时复制技术】可减少创建子进程时的性能损耗，加快创建速度

- **读数据**：

  - 创建bgsave子进程后，由于共享父进程的所有内存数据，就可以直接读取主线程（父进程）中的内存数据，并将数据写入到RDB文件中
  - 当主线程（父进程）对这些共享的内存数据也都是只读操作，则主线程（父进程）和bgsave子进程相互不影响如果

- **写数据**：

  - 如果主线程（父进程）要修改共享数据中的某块数据时，就会发生【写时复制】，该数据的物理内存会被复制一份，【主线程在该数据副本进行修改操作】，同时，其子进程将原来的数据写入到RDB文件（不会阻塞主线程）

  ​     =》主线程刚刚修改的数据无法同时写入RDB文件，只能交由下次bgsave快照

  ​     =》如果系统恰好在创建RDB快照文件后崩溃，则Redis将会丢失主线程在快照期间修改的数据

- **内存占用翻倍**：

  - 执行RDB快照期间，刚fork()创建子进程后，主进程和子进程会共享同一份物理内存，但主进程中途处理了写操作，修改了共享内存，则当前被修改数据的物理内存就会被复制一份（同份数据占用内存翻倍）

  - 极端情况下，如果所有的共享内存都被修改，则占用内存是原先的两倍

    =》针对写操作多的场景，要注意RDB快照过程中内存的变化情况，以防止内存被占满

  

# AOF日志

- Redis每执行一条写操作命令，该命令会先写入到内存，再采用追加的方式写入到一个文件中，宕机后，重启Redis，会去读取并执行该文件中的命令，以恢复数据  

  =》这种保存写操作命令到日志的方式，即是AOF（Append Only File）

- Redis中AOF持久化功能默认不开启，需要修改`redis.conf`配置文件中的参数：

  ```shell
  # 是否开启AOF持久化,默认关闭（no）
  appendonly no
  # 指定AOF持久化的文件名为appendonly.aof
  appendfilename appendonly.aof
  ```



## 持久化实现流程

- Redis的服务进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，向客户端发送命令回复；时间事件则负责执行像serverCron等需要定时运行的函数

- AOF持久化功能的实现可分为**命令追加**（append）、**文件写入**、**文件同步**三个步骤

  - 1）Redis执行完写操作命令后，会将写命令追加到`server.aof_buf`缓冲区

  - 2）通过`write()`系统调用，将`aof_buf`缓冲区的数据写入到AOF文件（此时数据并没有写入到磁盘，而是拷贝到了内核缓冲区Page_Cache），其后由内核将数据写入磁盘（对AOF文件进行同步）

  - 3）具体内核缓冲区的数据何时写入到磁盘，由内核决定（写回策略）

    ![image-20241211232616114](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241211232616114.png)

## 写回策略

- 在`redis.conf`配置文件中的 appendfsync配置有always、everysec、no三种选项

| 写回策略 | 写回时机               | 性能                             | 缺点                                   |
| -------- | ---------------------- | -------------------------------- | -------------------------------------- |
| always   | 同步写回               | 可靠性高，最大程度保证数据不丢失 | 每个写命令都要同步写回磁盘，性能开销大 |
| everysec | 每秒写回               | 性能适中                         | 宕机时会丢失1秒内的数据                |
| no       | 由操作系统控制写回时机 | 性能好                           | 宕机时可能会丢失很多数据               |

- 具体选择哪种写回策略，需要根据业务场景来决定：
  - 如果要高性能，就选择No策略
  - 如果要高可靠，就选择always策略
  - 如果稍微允许数据丢失，但又想拥有较高性能，则选择everysec策略

- 在操作系统中，为提高文件的写入效率，当用户调用`write函数`，将一些数据写入到文件时，操作系统会将写入数据暂时保存在一个内核缓冲区中，等缓冲区的空间被填满，或超过指定时限后，才真正将缓冲区的数据写入到磁盘

  =》虽提高了效率，但如果发生宕机，保存在内核缓冲区中的数据就会丢失

  =》为此，系统提供了fsync和fdatasync两个同步函数，可强制让操作系统立即将缓冲区中的数据写入到磁盘，以保证数据的安全性

## AOF重写机制



## AOF后台重写



