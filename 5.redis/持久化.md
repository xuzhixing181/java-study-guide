- Redis为保证数据不丢失，提供了【RDB快照】和【AOF日志】两种持久化方式
- RDB快照文件记录的是二进制的键值对数据，AOF日志文件记录的是Redis操作命令

# RDB快照

## save和bgsave

- RDB文件的加载工作是在服务器启动时自动执行的，而没有提供加载RDB的命令

- Redis提供了`save`和`bgsave`两种命令来生成RDB文件，其区别在于是否【在主线程执行】

  - 行`save`命令，就会在主线程生成RDB文件（和执行操作命令在同一个线程），如果写入RDB文件时间过长，会阻塞主线程
  - 执行`bgsave`命令，会创建一个子进程来生成RDB文件，以避免阻塞主线程

- Redis可通过`redis.conf`配置文件来实现每隔一段时间自动执行一次bgsave命令，默认会提供如下配置：

  ```shel
  save 900 1
  save 300 10
  save 60 10000
  ```

  只要满足如上配置的其中一个条件，就会执行bgsave命令，其意思为分别900秒、300秒、60秒之内，对数据库分别进行了至少1、10、10000次修改，就会【创建子进程来生成RDB快照文件】

## 原理探究

### bgsave实现结构

- 服务器save选项所设置的保存条件，被封装在saveparam结构体中

```c
struct redisServer {
    // ...
    struct saveparam *saveparams;
    // ...
    long long dirty;
    time_t lastsave;   
}
```

- saveparams：一个数组，数组中的每个元素都是一个都保存了一个save选项设置的保存条件（修改时间段的毫秒数，修改次数）
- dirty：自上次save或bgsave操作后，对服务器【所有数据库状态】进行【增删改的操作次数】，即成功执行了多少次修改数据库的操作，dirty计数器的值就增加多少（save或bgsave命令执行完成后，dirty计数器会重置为0）
- lasttime：UNIX时间戳，记录服务器 上次成功执行save或bgsave操作的时间戳（）

```C
struct saveparams{
    // 秒数
    time_t seconds;
    // 修改次数
    int changes;
}
```

```she
save seconds changes: 即服务器在seconds秒内,对数据库至少进行了changes次修改
```

### 检查保存条件是否满足

- Redis服务器的周期性操作函数serverCron默认每隔100毫秒执行一次，该函数会维护正在运行的服务器，其中一项工作即是检查save选项所设置的保存条件是否满足，如果满足，就执行bgsave命令

- serverCron函数检查保存条件的过程：

  1）遍历save设置的所有保存条件，计算**距离上次执行保存操作**有多少秒

  2）如果数据库状态的修改次数超过条件所设置的次数，且距离上次保存的时间超过条件所设置的时间，则执行bgsave操作

  只要有任意一个save条件被满足，就会执行bgsave操作

### RDB文件结构

- RDB文件包含内容如下（全大写单词标识常量，全小写单词标识变量和数据）：

![image-20241211211221113](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241211211221113.png)

- REDIS常量：RDB文件最开头的五个字符，程序以此在载入文件时，快速检查所载入文件是否为RDB文件
- db_version：字符串表示的整数，记录了RDB文件的版本号
- databases：包含零个或任意多个数据库，以及各个数据库中的任意键值对数据，database N：代表N号数据库中的所有键值对数据
- EOF常量：标识RDB文件正文内容的结束，当读入程序遇到该值，则所有数据库的所有键值对数据都已载入完毕
- check_sum：一个8字节长的无符号整数，由前面四个部分计算得出；服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum比较，以此来检查RDB文件是否存在出错或损坏的情况

## 存在问题

- RDB快照是全量快照，即每次执行快照，都会将内存中的【所有数据】都记录到磁盘中

  =》执行快照的操作较重，如果太过频繁，会影响Redis的性能；如果频率太低，服务器故障时，会丢失较多数据

- RDB是全量快照，执行频率不能太过频繁；而AOF是以秒级的频率来记录操作命令，丢失的数据会相对更少

  

## 执行快照时如何修改数据

- 执行bgsave的操作会交给子进程来生成RDB文件，主线程还可以继续工作，如何修改数据？

  =》实现的关键在于【写时复制技术(Copy-On-Write，COW)】

- 执行bgsave命令时，会通过`fork()`创建子进程，此时子进程和父进程共享同一内存数据

  =》创建子进程时，会复制父进程的页表，但页表指向的物理内存还是一个

  ​      只有在发生内存数据修改时，物理内存才会被复制一份

![image-20241210214703775](D:\study-code\java-study-guide\5.redis\images\写时复制技术图1.png)

- 由于创建子进程会阻塞主线程，而使用【写时复制技术】可减少创建子进程时的性能损耗，加快创建速度

- **读数据**：

  - 创建bgsave子进程后，由于共享父进程的所有内存数据，就可以直接读取主线程（父进程）中的内存数据，并将数据写入到RDB文件中
  - 当主线程（父进程）对这些共享的内存数据也都是只读操作，则主线程（父进程）和bgsave子进程相互不影响如果

- **写数据**：

  - 如果主线程（父进程）要修改共享数据中的某块数据时，就会发生【写时复制】，该数据的物理内存会被复制一份，【主线程在该数据副本进行修改操作】，同时，其子进程将原来的数据写入到RDB文件（不会阻塞主线程）

  ​     =》主线程刚刚修改的数据无法同时写入RDB文件，只能交由下次bgsave快照

  ​     =》如果系统恰好在创建RDB快照文件后崩溃，则Redis将会丢失主线程在快照期间修改的数据

- **内存占用翻倍**：

  - 执行RDB快照期间，刚fork()创建子进程后，主进程和子进程会共享同一份物理内存，但主进程中途处理了写操作，修改了共享内存，则当前被修改数据的物理内存就会被复制一份（同份数据占用内存翻倍）

  - 极端情况下，如果所有的共享内存都被修改，则占用内存是原先的两倍

    =》针对写操作多的场景，要注意RDB快照过程中内存的变化情况，以防止内存被占满

  

# AOF日志

- Redis每执行一条写操作命令，该命令会先写入到内存，再采用追加的方式写入到一个文件中，宕机后，重启Redis，会去读取并执行该文件中的命令，以恢复数据  

  =》这种保存写操作命令到日志的方式，即是AOF（Append Only File）

- Redis中AOF持久化功能默认不开启，需要修改`redis.conf`配置文件中的参数：

  ```shell
  # 是否开启AOF持久化,默认关闭（no）
  appendonly no
  # 指定AOF持久化的文件名为appendonly.aof
  appendfilename appendonly.aof
  ```



## 持久化实现流程

- Redis的服务进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，向客户端发送命令回复；时间事件则负责执行像serverCron等需要定时运行的函数

- AOF持久化功能的实现可分为**命令追加**（append）、**文件写入**、**文件同步**三个步骤

  - 1）Redis执行完写操作命令后，会将**写命令追加到`server.aof_buf`缓冲区**

  - 2）通过**`write()`系统调用，将`aof_buf`缓冲区的数据写入到AOF文件**（此时数据并没有写入到磁盘，而是拷贝到了内核缓冲区Page_Cache），其后由内核将数据写入磁盘的时机（对AOF文件进行同步）

  - 3）具体内核缓冲区的数据何时写入到磁盘，由内核决定（写回策略）

    ![image-20241211232616114](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241211232616114.png)

## 写回策略

- 在`redis.conf`配置文件中的 appendfsync配置有always、everysec、no三种选项

| 写回策略 | 写回时机               | 性能                             | 缺点                                   |
| -------- | ---------------------- | -------------------------------- | -------------------------------------- |
| always   | 同步写回               | 可靠性高，最大程度保证数据不丢失 | 每个写命令都要同步写回磁盘，性能开销大 |
| everysec | 每秒写回               | 性能适中                         | 宕机时会丢失1秒内的数据                |
| no       | 由操作系统控制写回时机 | 性能好                           | 宕机时可能会丢失很多数据               |

- 具体选择哪种写回策略，需要根据业务场景来决定：
  - 如果要高性能，就选择No策略
  - 如果要高可靠，就选择always策略
  - 如果稍微允许数据丢失，但又想拥有较高性能，则选择everysec策略

- 在操作系统中，为提高文件的写入效率，当用户调用`write函数`，将一些数据写入到文件时，操作系统会将写入数据暂时保存在一个内核缓冲区中，等缓冲区的空间被填满，或超过指定时限后，才真正将缓冲区的数据写入到磁盘

  =》虽提高了效率，但如果发生宕机，保存在内核缓冲区中的数据就会丢失

  =》为此，系统提供了fsync和fdatasync两个同步函数，可强制让操作系统立即将缓冲区中的数据写入到磁盘，以保证数据的安全性

- **服务器只要读入并重新执行一遍AOF文件中的命令，就可还原服务器关闭前的数据库状态**

## AOF重写机制

- 随着服务器写操作命令增多，AOF文件中的内容也会逐步增多，体积会越来越大，使用AOF文件来还原数据所需时间就越多，会影响Redis服务、甚至整个宿主计算机的性能

  =》为解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写的功能

  =》在重写时，读取当前数据库中的所有键值对数据，将每个键值对用一条命令记录到新的AOF文件中（避免单个键值对被多次修改而记录多条操作命令），等到全部命令记录完后，就用新的AOF文件替换掉现有的AOF文件

- 在没有使用AOF重写机制时，如果前后执行了`set name lisi`、`set name zhangsan`和`set name xzx`，这三个命令都会被记录到AOF文件中

  在使用重写机制后，就会读取name最新的value，只记录最新的操作命令`set name xzx`,前面的历史命令不会记录，AOF重写完成后，就会将新的AOF文件覆盖现有的AOF文件，使其AOF文件体积变小

- AOF重写时，为什么不直接复用现有的AOF文件？

  =》

  复用现有文件：如果AOF重写失败，现有的AOF文件就会造成污染，可能无法用于恢复数据

  新AOF替换原AOF文件：重写失败，则可直接删除该新AOF文件，不会对现有的AOF文件造成影响

## AOF后台重写

- 写入AOF日志的操作在主进程完成，写入内容不多，一般不太影响命令的操作
- 由于触发AOF重写的过程比较耗时，故重写操作不能在主进程中执行
  - 当AOF文件超过限定的大小时，会读取所有缓存的键值对数据，并为每个键值对生成一条命令，再将其写入到新的AOF文件中，重写完成后，就会将现有的AOF文件替换掉
- Redis重写AOF是由后台子进程bgrewriteaof来完成的，优势如下：
  - 子进程重写AOF时，主进程可以继续处理命令请求，从而避免阻塞主进程
  - 子进程带有主进程的数据副本（如果是使用线程，多线程之间会共享内存，在修改共享内存数据时，需要通过加锁来保证数据的安全，会降低性能）
  - 创建子进程后，父子进程以只读的方式共享内存，当父子进程任意一方修改了共享内存数据，就会发生**写时复制**，以此父子进程就拥有了独立的数据副本，不需要通过加锁来保证数据安全

### 写时复制

子进程如何拥有主进程相同的数据副本？

- 主进程通过**fork函数**系统调用生成bgrewriteaof子进程时，操作系统会将主进程的**页表**复制一份给子进程，该页表记录着虚拟地址和物理地址的映射关系，即父子进程的**虚拟内存不同**，但对应着**相同的物理内存**（页表对应页表项的属性会标记该物理内存的权限为只读）

  - 补充：在复制页表的过程中，父进程会阻塞，但页表相对于实际的物理内存较小，故复制页表的过程较快

  ![image-20241212221322497](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241212221322497.png)

- 写时复制：在发生写操作时，操作系统才会去复制物理内存，以防止fork创建子进程时，出现**物理内存数据的复制时间过长**而导致**父进程长时间阻塞**的问题

### AOF重写缓冲区

- 触发重写机制后，主进程就会**创建重写AOF的子进程**，此时**父子进程共享物理内存**，子进程会对该内存进行**只读**，重写AOF子进程会**读取数据库中的所有数据**，并**逐一将键值对转换为操作命令**，再将命令记录到新的AOF文件

  - 主进程修改了已经存在的key~value，就会发生写时复制（只会复制主进程修改的物理内存，没修改的物理内存还是和子进程共享）

    =》如果修改的是一个bigKey，复制**物理内存数据**的过程会**比较耗时**，**有阻塞主进程的风险**

  - 子进程AOF重写过程中，主进程依然可以正常处理命令请求，新的命令可能会修改现有数据库状态，**造成服务器现有的数据库状态**和**重写后的AOF文件所保存的数据库状态不一致**

  ​      =》为解决该数据不一致的问题，Redis实现了一个AOF重写缓冲区，在服务器创建子进程后开始使用该缓冲区

- 在重写AOF期间，当Redis执行完一个写命令后，会将该写命令 同时写入到【**AOF缓冲区**】和【**AOF重写缓冲区**】，即子进程执行AOF重写期间，主进程需要执行如下工作：
  - 1）执行客户端发来的命令
  - 2）将执行后的写命令追加到AOF缓冲区，AOF重写缓冲区

![image-20241213072242344](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241213072242344.png)

- 当子进程完成AOF重写工作（扫描数据库中所有数据，逐一将内存数据中的键值对转换成一条命令，并记录到新AOF文件）后，会向主进程发送信号，主进程收到该信号后，调用信号处理函数，该函数主要进行如下工作：

  - 1）将AOF重写缓冲区中的所有内容追加到新AOF文件，使新/旧AOF文件所保存的数据库状态相同
  - 2）对新AOF文件改名，原子地覆盖现有AOF文件

  信号处理函数执行完后，主进程就可以正常处理命令了

- 在整个AOF后台重写的过程中，除了【写时复制】、【执行信号处理函数】会对主进程造成阻塞，在其他时候，AOF后台重写都不会阻塞主进程



参考资料：

- 《Redis设计与实现》
- 小林coding-图解Redis

