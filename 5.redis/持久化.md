- Redis为保证数据不丢失，提供了【RDB快照】和【AOF日志】两种持久化方式
- RDB快照文件记录的是二进制数据，AOF日志文件记录的是Redis操作命令

## RDB快照

### save和bgsave

- RDB文件的加载工作是在服务器启动时自动执行的，而没有提供加载RDB的命令

- Redis提供了`save`和`bgsave`两种命令来生成RDB文件，其区别在于是否【在主线程执行】

  - 行`save`命令，就会在主线程生成RDB文件（和执行操作命令在同一个线程），如果写入RDB文件时间过长，会阻塞主线程
  - 执行`bgsave`命令，会创建一个子进程来生成RDB文件，以避免阻塞主线程

- Redis可通过`redis.conf`配置文件来实现每隔一段时间自动执行一次bgsave命令，默认会提供如下配置：

  ```shel
  save 900 1
  save 300 10
  save 60 10000
  ```

  只要满足如上配置的其中一个条件，就会执行bgsave命令，其意思为分别900秒、300秒、60秒之内，对数据库分别进行了至少1、10、10000次修改，就会【创建子进程来生成RDB快照文件】

### bgsave底层实现

```c
struct redisServer{
    saveparams
    dirty
    lasttime     
}
```

- dirty：自上次save或bgsave操作开始，对数据进行增删改的操作次数
- lasttime：距离上次执行save或bgsave操作的时间戳

```C
struct saveparams{
    // 秒数
    // 修改次数
}
```



### 存在问题

- RDB快照是全量快照，即每次执行快照，都会将内存中的【所有数据】都记录到磁盘中

  =》执行快照的操作较重，如果太过频繁，会影响Redis的性能；如果频率太低，服务器故障时，会丢失较多数据

- RDB是全量快照，执行频率不能太过频繁；而AOF是以秒级的频率来记录操作命令，丢失的数据会相对更少



### 如何执行快照时修改数据

- 执行bgsave的操作会交给子进程来生成RDB文件，主线程还可以继续工作，如何修改数据？

  =》实现的关键在于【写时复制技术(Copy-On-Write，COW)】

- 执行bgsave命令时，会通过`fork()`创建子进程，此时子进程和父进程共享同一内存数据

  =》创建子进程时，会复制父进程的页表，但页表指向的物理内存还是一个

  ​      只有在发生内存数据修改时，物理内存才会被复制一份

![image-20241210214703775](D:\study-code\java-study-guide\5.redis\images\写时复制技术图1.png)

- 由于创建子进程会阻塞主线程，而使用【写时复制技术】可减少创建子进程时的性能损耗，加快创建速度

- 读数据：

  - 创建bgsave子进程后，由于共享父进程的所有内存数据，就可以直接读取主线程（父进程）中的内存数据，并将数据写入到RDB文件中
  - 当主线程（父进程）对这些共享的内存数据也都是只读操作，则主线程（父进程）和bgsave子进程相互不影响如果

- 写数据：

  - 如果主线程（父进程）要修改共享数据中的某块数据时，就会发生【写时复制】，该数据的物理内存会被复制一份，【主线程在该数据副本进行修改操作】，同时，其子进程将原来的数据写入到RDB文件（不会阻塞主线程）

  ​     =》主线程刚刚修改的数据无法同时写入RDB文件，只能交由下次bgsave快照

  ​     =》如果系统恰好在创建RDB快照文件后崩溃，则Redis将会丢失主线程在快照期间修改的数据

- 内存占用翻倍：

  - 执行RDB快照期间，刚fork()创建子进程后，主进程和子进程会共享同一份物理内存，但主进程中途处理了写操作，修改了共享内存，则当前被修改数据的物理内存就会被复制一份（同份数据占用内存翻倍）

  - 极端情况下，如果所有的共享内存都被修改，则占用内存是原先的两倍

    =》针对写操作多的场景，要注意RDB快照过程中内存的变化情况，以防止内存被占满

  

## AOF日志

