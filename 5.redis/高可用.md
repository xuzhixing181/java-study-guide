# 主从复制

## 全量复制
主从服务器之间第一次同步数据（全量复制）可分为如下三个阶段：

### 1）建立连接，协商同步

- 服务器B要成为服务器A的从服务器，则需要使用`replicaof <服务器A的IP地址> <服务器A的Redis端口>`

  其后从服务器会给主服务器发送`psync <runID> <offset>`命令，表示要进行数据同步

  - runID：主服务器的runID，每个Redis服务器启动时都会随机生成一个唯一的ID来表示自己，主从第一次同步，不知道主服务器的ID，则其值为?
  - offset：主从复制的进度，当主从第一次同步时，其值为-1

- 主服务器接收到psync命令后，将 `FULLRESYNC <runID> <offset>`作为响应返回给从服务器
  - 其中，runID表示主服务器唯一的标识ID，offset为主服务器目前的复制进度，从服务器收到响应后，会记录这两个值
    FULLRESYNC 响应目的：采用全量复制的方式，将主服务器会将所有的数据都同步给从服务器

### 2）主服务器全量同步数据给从服务器

- 主服务器系统调用fork出一个**子进程，来执行`bgsave`命令来生成RDB文件**，将**RDB文件发送给从服务器**
  从服务器接收到RDB文件后，会先清空当前的数据，再载入RDB文件
  
- 为保证主从服务器的数据一致性，**主服务器会将**如下时刻中**新接收到的写操作命令**，写入到【**replication buffer**】缓冲区中

  - 主服务器**生成RDB**文件期间

  - 主服务器将**RDB文件发送给从服务器**期间

  - **从服务器 加载RDB**文件期间

### 3）主服务器发送新的写操作同步给从服务器

- 从服务器**加载完RDB文件**后，会返回一个**ACK确认消息给主服务器**
- 主服务器`replication buffer`**缓冲区中所记录的写操作命令发送给从服务器**，从服务器执行发送过来的写操作命令，完成主从服务器数据的一致性

## 基于长连接的命令传播
- 主从服务器在完成第一次同步后，双方会维持一个TCP长连接（使用长连接，可避免频繁的TCP连接和断开造成的性能开销）
- 后续主服务器会使用该长连接，将接收到的写操作命令传播给从服务器，然后从服务器执行该命令，使得**主从服务器的数据库状态相同**

## 增量复制
- 当主从服务器之间可使用TCP长连接来传播命令后，如果主从服务器断开连接后，就无法传播命令，主从服务器的数据库状态就可能会不一致，导致客户端可能在从服务器读取到的数据是旧的

- 在Redis2.8之前，如果主从服务器在命令同步时出现网络断开又恢复的情况，主从服务器会重新进行全量复制，开销过大，需要优化

  在Redis2.8后，网络断开又恢复后，主从服务器会采用增量复制的方式继续同步，即只将**网络断开期间**【主服务器接收到的写操作命令】同步给从服务器

- 网络恢复后，增量复制的过程如下：
  
  - 1）从服务器发送`psync <runID> <offset>`给主服务器
  - 2）主服务器接收到psync命令后，响应 continue命令给从服务器，告知从服务器通过 **增量复制 来同步数据**
  - 3）主服务器将断线期间，执行的写操作命令发送给从服务器，从服务器再执行这些命令
  
- **主服务器如何确定发送给从服务器的增量数据有哪些？**
  
  通过环形缓冲区来存储新发送给从服务器的增量数据，offset来标记主从服务器中数据的同步进度
  
  - 【repl_backlog_buffer】：环形缓冲区，用于主从服务器断连后，从中找到差异的数据
  - 【replication offset】：标记环形缓冲区中数据的复制进度，主从服务器都有各自的偏移量，主服务器使用`master_repl_offset`来标记自己【写】数据的进度，从服务器使用`slave_repl_offset`来标记自己【读】数据的进度
  
- **数据写入repl_backlog_buffer的时机？**

  - 在**主服务器传播命令**时，会将写命令发送给从服务器和**写入到repl_backlog_buffer缓冲区中**

  - 在网络断开后，当从服务重新连接上主服务器时，从服务器会通过 psync命令将复制偏移量`slave_repl_offset`发送给主服务器，主服务器根据`master_repl_offset`和`slave_repl_offset`两者的差距，来决定从服务器执行哪种同步操作

    - 如果从服务器要读取的数据还在`repl_backlog_buffer`缓冲区中，则主服务器采用**增量复制**来同步数据，不在则采用全量复制

  - 当主服务器在repl_backlog_buffer中找到主从服务器之间的差异数据后，就会将增量数据写入到**`replication_buffer`缓冲区**（该缓冲区会**存储要传播给从服务器的命令**）

    ![image](https://github.com/user-attachments/assets/353f5a10-23e1-487c-bc89-e2b2ddd7dccf)




- repl_backlog_buffer默认大小为1M，当缓冲区写满后，主服务器如果继续写入，就会覆盖掉之前的数据

  =》当主服务器的**写入速度**远超**从服务器的读取速度**，缓冲区的数据就会被快速覆盖（主从服务器断连后，从服务器要读取的数据被覆盖），从而触发从服务器的全量复制

- 为避免网络恢复时，主服务器频繁地使用全量复制，可调整下`repl_backlog_buffer`的大小，以尽可能地减少从服务器要读取的数据被覆盖的情况

- **`repl_backlog_buffer`的大小如何调整？**

  repl_backlog_buffer的大小可在`redis.conf`中配置，默认配置如下：

  ```conf
  repl-backlog-size 1mb
  ```

  其参数配置可参考公式：repl-backlog-size = second * write-size-per-second

  - second：从服务器**断线重连主服务器**所需的平均时间（以秒为单位）
  -  write-size-per-second：主服务器**平均每秒产生写命令**的数据量大小
  - 为应对某些突发情况，需要将repl-backlog-size设置为 2* second * write-size-per-second

补充：

repl_backlog_buffer 和 replication buffer的区别：

- 出现的阶段不同：
  - repl_backlog_buffer：在增量复制阶段出现，一个主节点只分配一个repl_backlog_buffer
  - replication buffer：在全量复制阶段和增量复制阶段都会出现，**主节点会给每个新连接的从节点，都分配一个replication buffer**
- 当缓冲区满了后，对应的操作不同：
  - 当repl_backlog_buffer环形缓冲区满了后，会直接覆盖起始位置的数据
  - 当replication buffer满了，会断开连接，删除缓存，从节点重新连接，重新开始全量复制

![image-20241225225750016](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241225225750016.png)
![image](https://github.com/user-attachments/assets/96551018-9b04-4fb6-9fee-ddf632d83462)




## 小结

- 主从复制共有【全量复制】、【基于长连接的命令传播】、【增量复制】

- 主从服务器第一次同步，采用全量同步，同步完成后，主从服务器会维护一个长连接，后续主服务器在接收到写操作命令后，会通过该连接将写命令传播给从服务器和`repl_backlog_buffer`环形缓冲区，以保证主从服务器的数据一致性

- 如果出现网络故障，主从服务器断连后又恢复连接，如果主服务器 repl_backlog_buffer中的数据没有被覆盖，增量复制来同步数据；被覆盖了则采用全量复制来同步数据

  =》为避免频繁地全量复制，则调大repl_backlog_buffer的大小，即调大repl-backlog-size 参数值的大小，以降低主从服务器断连又恢复连接后 全量同步的概率



