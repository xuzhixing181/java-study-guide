## 缓存介绍

- 缓存，即是数据交换的缓冲区（Cache），用于存储数据，一般读写性能较高
- 缓存的作用：
  - 降低后端负载
  - 提高读写效率，降低响应时间
- 缓存的成本：
  - 数据一致性成本
  - 代码维护和运维成本

## 缓存更新策略

- 内存淘汰：利用Redis的内存淘汰机制来更新缓存（惰性删除+定期删除），当内存不足时自动淘汰部分数据，下次查询时更新缓存
- 超时剔除：给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存
- 主动更新：编写业务逻辑，在修改数据库时更新缓存

根据业务场景来选择缓存更新策略：

- 低一致性需求：使用内存淘汰机制
- 高一致性需求：主动更新，并以超时剔除作为兜底方案

缓存主动更新策略分为Cache Aside Pattern（旁路缓存策略）、Read/Write Through Pattern（读写穿透）、Write Behind Pattern（异步缓存策略）

### Cache Aside Pattern

- Cache Aside Pattern（旁路缓存模式）：平时使用较多，适合读多写少的场景

  - 服务端需要同时维护数据库和缓存，且以数据库中的数据为准
  - 对于读操作：1）先更新数据库  2）在删除缓存
  - 对于写操作：1）先查询缓存  2）缓存未命中，则查询数据库并返回  3）重建缓存数据

- 举例说明：假设数据库和缓存中存在数据v都为10，线程1查询缓存未命中后查询数据库，查出的数据v = 10，

  其后，线程2更新数据库将v = 20，再删除缓存，线程1再写入缓存v = 10，

  而此时数据库中的数据v=20，缓存中的v=10，此时会出现数据不一致的情况，但概率极低，因为缓存的写入速度要远远快于数据库的写入速度，真实情况往往是单个线程先操作数据库，在操作缓存（如：线程2先更新数据库再删除缓存，线程1再查询缓存，未命中再查询数据库，写入缓存）

  =》为避免个别暂时数据不一致的情况，可在写入缓存时设定超时时间，缓存过期后，会走查询数据库更新缓存的逻辑

  ![image-20241230081457035](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241230081457035.png)

#### 先删除缓存，再更新数据库可以吗

- 举例说明：假设数据库和缓存中存在数据v都为10，线程1先删除缓存，与此同时，线程2查询缓存但未命中后，会查询数据库v=10，并写入缓存v=10，其后，线程1更新数据库v=20，其结果是缓存中v=10，数据库中v=20，由于缓存的写入速度要远远快于数据库的写入速度，所以这种情况发生的概率较大，出现数据不一致的风险较高

![image-20241230080405446](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241230080405446.png)

Cache Aside Pattern存在的问题：

- 问题1：首次请求数据一定不在缓存的问题
  - 解决方案：将热点数据提前存入缓存
- 问题2：写操作较频繁会导致缓存中的数据会被频繁删除，影响缓存命中率
  - 解决方案：
    - 针对强一致性场景，更新数据库的同时更新缓存，并通过锁/分布式锁来保证更新缓存时不存在线程安全问题
    - 针对允许短暂不一致的场景：更新数据库的同时更新缓存，并为缓存添加一个较短的过期时间，以保证即便出现数据不一致性，其影响也比较小

### Read/Write Through Pattern

- Read/Write Through Pattern模式下，缓存服务负责将数据读取和写入数据库，以减轻应用程序的职责
- 写操作（Write Through）：
  - 1）先查询缓存，缓存未命中再更新数据库
  - 2）缓存命中，则先更新缓存，由缓存服务自行更新数据库（客户端来看即是同时更新缓存和数据库）
- 读操作（Read Through）：
  - 1）从缓存中读取数据，读取到则就直接返回
  - 2）读取不到则从数据库加载，并写入到缓存后返回

- Read/Write Through Pattern实际只是在Cache Aside Pattern上进行了封装，在Cache Aside Pattern模式下，发送读请求时，如果缓存中不存在对应的数据，则由客户端负责将数据写入缓存，而Read/Write Through Pattern则由缓存自行写入缓存，该过程对客户端透明
- Read/Write Through Pattern和Cache Aside Pattern一样，首次请求数据不在缓存中，则可以将热点数据提前放入缓存

### Write Behind Pattern

- Write Behind Pattern 和 Read/Write Through Pattern 都是由**缓存服务来负责缓存和数据库的读写**

  其最大的不同在于Read/Write Through是同步更新缓存和数据库，而Write Behind 则是只直接更新缓存，**异步批量更新数据库**（而不是直接更新数据库），这对数据一致性带来较大挑战，如：缓存数据可能会没异步更新到数据库，缓存服务可能就挂了

- Write Behind Pattern（异步缓存写入）在平时开发中极为少见，但也不缺其应用场景，如：MQ中的消息异步写入磁盘、MySQL中的InnoDB Buffer Pool都用到了异步写入的策略

- Write Behind Pattern模式下，数据库的写性能非常高，非常适合一些数据频繁更新，且对数据一致性要求不高的场景，如：浏览量、点赞量

### 小结

缓存更新策略的最佳实践：

- 低一致性需求：使用Redis自带的内存淘汰机制
- 高一致性需求：主动更新，并以超时淘汰 作为兜底方案
  - 读操作：缓存命中则直接返回；**缓存未命中，则查询数据库，写入缓存并设定超时时间**
  - 写操作：**先写数据库，再删除缓存**；需确保数据库和缓存操作的原子性

## 缓存穿透

### 问题描述

- 缓存穿透：客户端请求的数据在缓存和数据库中都不存在，缓存永远不存在，请求打到数据库，会导致数据库的压力陡增，后续也无法构建缓存数据来缓解压力
- 导致缓存穿透的情况可能会有如下两种：
  - 1）业务误操作：缓存和数据库中的数据都被删除
  - 2）用户恶意攻击：故意大量访问某些不存在的业务数据

### 解决方案

#### 1）非法请求的限制

- 在API入口处新增对请求参数的校验（是否含有非法值、请求字段是否存在），如判断出是恶意请求就直接返回，避免进一步访问缓存和数据库
- 优缺点：实现简单，但对恶意请求的限制非常有限

#### 2）缓存空值或默认值

- 当线上业务发送缓存穿透时，可针对查询数据，在缓存中设置空值或默认值，后续请求就可从缓存中读取到空值或默认值后直接返回，而不会继续查询数据库

- 优缺点：实现简单，维护方便；但会额外地消耗内存，可能会造成短期的数据不一致

  ![image-20241229102807720](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241229102807720.png)

#### 3）布隆过滤器

- 使用布隆过滤器快速判断数据是否存在，如不存在则可直接返回，如存在才会放行请求，让其访问缓存等后续操作

- 优点：内存占用较少，没有多余key、

- 缺点：实现复杂，存在误判的概率，不能删除或更新数据

  ​           要根据业务场景**合理选择哈希函数的数量**和**布隆过滤器的大小**，以平衡准确性和空间效率

![image-20241229102721801](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241229102721801.png)



## 缓存击穿

### 问题描述

- 缓存击穿，也称为热点key问题，即被高并发访问且缓存重建业务较为复杂的key突然失效了，无数的请求访问会瞬间使数据库的压力陡增

  ![image-20241229114129213](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241229114129213.png)

- 缓存击穿常见的解决方案有互斥锁、逻辑过期

### 解决方案

#### 互斥锁

![image-20241229104801726](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241229104801726.png)

- 如上图所示，线程1如果查询缓存未命中，则获取互斥锁，获取到锁后**查询数据库**【重建缓存数据】，写入缓存后再释放锁；线程2查询缓存未命中，由于互斥锁已被线程1获取，线程2则无法再获取到互斥锁，只能休眠一段时间再重试，休眠期间，线程1可能完成了缓存数据的重建，线程2再次查询缓存，结果缓存命中，可直接返回

#### 逻辑过期

![image-20241229112419027](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241229112419027.png)

- 使用Hash结构，为数据新增表示 逻辑过期时间的时间戳字段，如上图，当线程1查询缓存，根据逻辑时间判断数据是否过期，如果已过期，则尝试获取互斥锁，获取成功则开启异步线程去重建缓存数据，当前线程则可立即返回过期数据 
  - 由异步线程去查询数据库并重建缓存数据，写入缓存重置逻辑过期时间，再释放锁
  - 其他线程再来查询缓存，如果发现逻辑时间已过期，且获取锁失败，会直接返回过期数据；如果逻辑时间没有过期，且缓存命中，则直接返回缓存数据

缓存击穿的解决方案总结：

| 解决方案 | 优点                  | 缺点                        |
| -------- | --------------------- | --------------------------- |
| 互斥锁   | 1）没有额外的内存消耗 | 1）线程需要等待，会影响性能 |
|          | 2）可保证数据一致性   | 2）有死锁风险               |
|          | 3）实现简单           |                             |
| 逻辑过期 | 线程无需等待，性能好  | 1）不保证数据的一致性       |
|          |                       | 2）有额外的内存消耗         |
|          |                       | 3）实现复杂                 |



## 缓存雪崩

- 缓存雪崩：在同一时段大量的缓存key同时失效或Redis服务宕机，导致大量请求到达数据库 使其压力陡增
- 解决方案：
  - 1）给不同key在TTL的基础上添加随机值，分散key的过期时间
  - 2）利用Redis集群提高服务可用性
  - 3）给缓存业务添加限流降级策略
  - 4）给业务添加多级缓存（如本地缓存+远程缓存）

