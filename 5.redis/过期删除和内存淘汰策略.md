# 过期删除策略

## 如何设置过期时间

- 在设置字符串的同时，对key设置过期时间，有如下三个命令：

  - `set <key> <value> ex <n>`、`setex <key> <n> <value>`：设置键值对，并指定其过期时间（精确到秒）
  - `set <key> <value> px <n>`：设置键值对并指定其过期时间（精确到毫秒）

  1）如果要**查看key剩余的存活时间**，可使用`ttl <key>` 或`pttl <key>`命令，执行结果为大于0，则表示key未过期；为-2，则表示key已过期

  - TTL和PTTL的不同在于`TTL`以秒为单位，`PTTL`以毫秒为单位，两者都是通过计算key的过期时间和当前时间的差值来实现的

  2）如果要**取消key的过期时间**，可使用`persist <key>`命令，执行完后，在`ttl <key>`查看，则结果为-1，则表示key永不过期

- - `expire <key> <n>`：设置key在n秒后过期，如：expire testKey 100 表示设置testKey在100秒后过期
  - `pexpire <key> <n>`：设置key在**n毫秒**后过期
  - `expireat <key> <n>`：设置key在某个时间戳（**精确到秒**）后过期，如：expireat exKey 1734140315870 表示exKey在时间戳1734140315870后过期
  - `pexpireat <key> <n>`：设置key在某个时间戳（**精确到毫秒**）后过期

## 如何判定key已过期

- Redis服务器中的每个数据库都由一个`redis.h/redisDb`结构体表示：

```c
typedef struct redisDb {
    // ...
    dict *dict;       // 数据库键空间,保存着数据库中的所有键值对
    dict *expires;    // 过期字典,保存着键的过期时间
}
```

- dict键空间：
  - dict键空间和用户所见的数据库直接对应，键空间的key或value即是数据库中的key或Value，每个key都是一个字符串对象，每个value可以是String或复合类型（List、Hash、Set、ZSet）对象中的任意一种Redis对象
- expires过期字典：key为指针，指向某个键对象；value是一个long long类型的整数（一个毫秒精度的UNIX时间戳），记录key的过期时间（判断过期时，会计算该过期时间和当前时间的差值来判断key是否过期）

![image-20241214102011972](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20241214102011972.png)

```md
键空间的key和过期字典的key都是同一个键对象,故不会出现任何重复对象，也不会浪费任何空间（上图重复出现了键对象,只是为方便展示）
```



- dict实际上就是哈希表，其最大好处是以O(1)的时间复杂度来快速查找，当查询一个key时，Redis会先检查该key是否存在于过期字典中：
  - 如果不在，则正常读取键值对
  - 如果存在，则会获取该key的过期时间，再与当前系统时间做比较，如果比系统时间大，则没有过期，否则判定该key已过期

## 过期删除策略

- 如果一个键已过期，可以选择的过期删除策略：**定时删除**、**惰性删除**、**定期删除**，而Redis采用的策略为**惰性删除**和**定期删除**

### 定时删除

- 定时删除策略：设置key的过期时间时，创建一个**定时器**（定时事件），当时间到达时，由**事件处理器自动执行key的删除操作**
- 优点：可保证过期key被尽快删除，内存被尽快释放，**对内存最友好**
- 缺点：
  - 1）在过期key较多，CPU时间紧张时，将**CPU时间用于删除和当前任务无关的过期键**，占用较多CPU时间，会影响服务器的吞吐量和响应时间，**对CPU不友好**
  - 2）创建一个定时器依赖于Redis服务器中的时间事件，而当前时间事件通过无序链表来组织，其查找的时间复杂度为O(N)，即不能高效地处理大量时间事件

### 惰性删除

- 惰性删除策略：不主动删除过期键，每次访问数据库中的key时，都检测key是否过期，如果过期则删除该key
- 优点：不会在删除任何与业务无关的过期键上浪费任何CPU时间，**对CPU时间最友好**
- 缺点：存在内存泄露的风险（**无用的垃圾数据占用大量内存**），如果数据库中存在大量过期的键，且这些过期键长期不被访问，其占用内存就不会释放，**对内存不友好**

### 定期删除

- 定期删除策略：**每隔一段时间**，**随机**从数据库中取出一定数量的key进行检查，并删除其中的过期key

- 优点：**限制删除操作执行的时长和频率**，**减少删除操作对CPU的影响**，同时也能删除一部分过期的数据，以减少过期键对内存的无效占用

- 缺点：

  - **没有定时删除的内存清理效果好**；

  - **难以确定删除操作执行的时长和频率**：如果执行地太频繁，则和定时删除一样，对CPU不友好；如果执行次数太少，则和惰性删除一样，过期key占用的内存不会及时释放

## Redis的过期删除策略

- Redis为合理使用CPU时间和避免浪费内存，采用【**惰性删除+定期删除**】搭配使用的**折中策略**

### 如何实现惰性删除

- Redis的惰性删除策略由db.c文件中的expireIfNeeded函数实现，伪代码如下：

  ```C
  int expireIfNeed(redisDb *db, robj *key) {
      // 判断key是否过期
      if(!keyIsExpired(db,key)) return 0;
      
      // ...
      
      // 删除过期键
      
      // ...
      // 如果server.lazyfree_lazy_expire 为1,则表示异步删除,反之同步删除
      return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);
  }
  ```

- Redis在访问或修改key之前，都会调用expireIfNeeded函数对其检查，检查key是否过期（在命令真正执行前，过滤掉过期的key，以避免命令接触到过期键）：

  - 如果没有过期，则不做任何处理，返回正常的键值对给客户端

  - 如果过期，则删除该key，根据lazyfree_lazy_expire参数（Redis4.0+开始提供）决定删除key的方式，参数值为1，则异步删除，反之同步删除

### 如何实现定期删除

- 再回顾下Redis定期删除的做法：**每隔一段时间**，从数据库中**随机取出一定数量**的key进行检查，并删除过期的key

#### 间隔检查的时间是多长

- 该时间间隔在`redis.conf`文件中配置，配置键为hz，默认值为10，即默认每秒进行10次**数据库键的过期检查**

  =》是**从数据库中随机抽取一定数量的key进行过期检查**，而非遍历过期字典中的所有key

#### 随机抽查的数量是多少

- 定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis服务器**周期性地执行redis.c/serverCron函数**时，activeExpireCycle函数就会被调用，**在规定时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间**，并删除其中的过期键

  整个过程伪代码如下：

```c
# 默认每次检查的数据库数量
DEFAULT_DB_NUMBERS = 16;
# 默认每个数据库检查键的数量
DEFAULT_KEY_NUMBERS = 20;
# 全局变量,记录检查进度
current_db = 0;

def activeExpireCycle():
   # 初始化要检查的数据库数量,服务器真实的数据库数量和DEFAULT_DB_NUMBERS取最小者
   db_numbers = min(server.dbnum,DEFAULT_DB_NUMBERS)
   
    遍历各个数据库
   for i in range(db_numbers):

      # 如果已遍历完服务器的所有数据库一次,则current_db重置为0,开始新一轮的遍历
      if current_db == server.dbnum:
          current_db = 0
              
      # 获取当前要处理的数据库
      redisDb = server.db[current_db]
      # 数据库索引自增1,指向下一个要处理的数据库         
      current_db += 1
              
      # 随机抽取20个键检查
      for j in range(DEFAULT_KEY_NUMBERS):      

          # 如果数据库中没有一个键值对带有过期时间,则跳过该数据库
          if redisDb.expires.size() == 0: break

          # 随机获取一个带有过期时间的键
          key_With_ttl = redisDb.expires.get_random_key()
              
          # 检查键是否过期,如果过期则删除
          # ...
          
          # 如果达到时间上限,则停止处理
          if reach_time_limit(): return    
```



# 内存淘汰策略

## 如何设置Redis最大运行内存



## Redis内存淘汰策略



## LRU算法和LFU算法



