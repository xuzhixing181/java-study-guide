# 基本介绍

## 是什么

- 定时任务是预设时间或周期自动触发的程序逻辑，用于处理无需人工干预的重复性操作，适用于数据同步、报表生成、消息推送等场景，其核心是通过规则配置（如Cron表达式）定义执行时机，实现任务自动化管理

- 任务调度：

  我们可以思考一下下面业务场景的解决方案:

  - 某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券
  - 某银行系统需要在信用卡到期还款日的前三天进行短信提醒
  - 某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总

  以上场景就是任务调度所需要解决的问题，**任务调度是在约定的特定时刻，去自动完成特定任务的过程**

- XXL-JOB是美团开源的分布式任务调度框架，核心设计目标是轻量、易扩展、学习成本低，通过**解耦"调度中心"和"执行器"，实现任务调度和业务逻辑分离，支持动态配置、集群部署和可视化监控**，解决了传统定时任务在分布式场景下的痛点

  官方文档：[分布式任务调度平台XXL-JOB](https://www.xuxueli.com/xxl-job/#2.1 初始化“调度数据库”)



## 为什么用

### 传统定时任务的不足

- 使用Spring中提供的注解@Scheduled，也能实现调度任务的功能 =》在业务类中方法中加上@Scheduled注解+Cron表达式，然后在启动类上贴上`@EnableScheduling`注解

  ```java
  @Scheduled(cron = "0/20 * * * * ? ")
   public void doWork(){
   	//doSomething   
   }
  ```

- Spring提供的注解似乎可以完美实现任务调度的功能，为什么还需要分布式呢？

  主要有如下这几点原因:

  - 1）**高可用**（集群问题）：单机版的定时任务调度只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用

  - 2）**防止重复执行**（无分布式协调机制）

    在单机模式下，Spring的@Scheduled注解实现定时任务没啥问题，但当部署了多个服务，同时每个服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，定时执行的结果则可能存在混乱和错误，

    即**Spring Task在集群部署时会导致任务重复执行**

    **任务开启/暂停需要重启服务，无法动态调整参数或查看实时日志**

  - 3）**单机处理极限**：

    原本1分钟内需要处理1万个订单，但现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来

    多线程并行处理也确实可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），单机总会有处理不过来的情况

  - 4）容错性差：缺乏失败重试、报警机制，任务执行状态难以追踪

### XXL-JOB

- XXL-JOB：大众点评的分布式任务调度平台，是一个轻量级分布式任务调度平台, 其核心设计目标是开发迅速、学习简单、轻量级、易扩展，架构图如下：

  ![image-20250301115230261](C:\Users\xyl\AppData\Roaming\Typora\typora-user-images\image-20250301115230261.png)

- 如上，从整体到局部，XXL-JOB分为调度中心和执行器，调度中心相当于公司管理者，管理分配任务（任务被抽象成JobHandler，交由执行器统一管理）；**执行器**相当于员工，执行任务，员工要先在公司**完成注册（注册线程调用注册服务）**，再**由调度中心通过调度器来调用执行器，执行器负责完成任务的请求调度，并向调度中心汇报进度和执行情况（日志）**

  **调度中心可管理任务的执行情况，并提供可视化的监控面板**

  如此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性

XXL-JOB的优势如下：

- 分布式支持：
  - 调度中心HA：支持集群部署，通过共享数据库来保证一致性
  - 执行器HA：任务自动分片、故障转移，避免单点故障
- 动态管理：支持Web界面实时修改任务参数，启动/暂停任务，无需重启服务
- 丰富的路由策略：轮询、随机、分片广播等，适用于不同的业务场景
- 监控和报警：提供实时日志，失败重试，邮件报警等功能，提升系统可靠性

### 如何用

#### 基本配置

- 数据库初始化：执行官方SQL脚本（如`tables_xxl_job.sql`），包括任务信息、日志、执行器注册等

- 调度中心部署：

  - 通过Docker或源码启动`xxl-job-admin`模块，配置数据库连接和端口716。
  - 访问`http://localhost:8080/xxl-job-admin`，默认账号`admin/123456`1516。

- 执行器配置：

  - 引入`xxl-job-core`依赖，配置调度中心地址和应用名115。

  - 示例配置：

    ```properties
    xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin
    xxl.job.executor.appname=xxl-job-demo
    xxl.job.executor.port=9999
    ```

- Bean模式：使用`@XxlJob`注解定义任务逻辑，与调度中心配置的JobHandler名称一致

```Java
@Component
public class DemoJob {
    @XxlJob("demoJobHandler")
    public ReturnT<String> execute(String param) {
        XxlJobHelper.log("任务执行中...");
        return ReturnT.SUCCESS;
    }
}
```

- GLUE模式：支持在线编写脚本（如Shell、Python），实时生效

- 任务管理

  - 创建执行器**：在调度中心添加执行器集群，支持自动注册或手动录入地址**

  - 配置任务：

    1）选择路由策略（如分片广播）、阻塞处理策略（如丢弃后续调度）

    2）设置Cron表达式（如`0 0 3 * * ?`表示每天3点执行），Cron表达式可由[Cron - 在线Cron表达式生成器](https://cron.ciding.cc/)生成

####  高级功能

- **分片任务**：大数据处理时，任务分片到多个执行器并行执行，提升效率
- **故障转移**：某节点宕机时，自动切换至健康节点执行17。
- **日志追踪**：通过Rolling日志实时查看执行详情，支持ELK集群

- **路由策略**：当执行器集群部署时，提供丰富的路由策略，包括:
  - 1）FIRST（第一个）：固定选择第一个机器
  - 2）LAST（最后一个）：固定选择最后一个机器
  - 3）ROUND（轮询）：依次的选择在线的机器发起调度
  - 4）RANDOM（随机）：随机选择在线的机器
  - 5）**`CONSISTENT_HASH(一致性HASH):`每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器**
  - 6）LEAST_FREQUENTLY_USED(最不经常使用):使用频率最低的机器优先被选举
  - 7）LEAST_RECENTLY_USED(最近最久未使用)：最久未使用的机器优先被选举
  - 8）FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度
  - 9）BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度
  - 10）SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务



# 进阶应用详解

## 分片任务

- 在 XXL-JOB 中，分片任务是指**将一个大任务分解成多个小任务**，**这些小任务可以分布在不同的执行器上并行执行**，可以有效地录用集群资源，加快任务执行速度，**特别适用于数据量比较大的批处理任务**

- 需求:我们现在实现这样的需求，在指定节假日，需要给平台的所有用户去发送祝福的短信

### 需求初步实现

- 1）在MySQL数据库中执行如下SQL：

  ```sql
  CREATE database if NOT EXISTS `xxl_job` default character set utf8mb4 collate utf8mb4_unicode_ci;
  use `xxl_job`;
  
  SET NAMES utf8mb4;
  
  CREATE TABLE `xxl_job_info` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `job_group` int(11) NOT NULL COMMENT '执行器主键ID',
    `job_desc` varchar(255) NOT NULL,
    `add_time` datetime DEFAULT NULL,
    `update_time` datetime DEFAULT NULL,
    `author` varchar(64) DEFAULT NULL COMMENT '作者',
    `alarm_email` varchar(255) DEFAULT NULL COMMENT '报警邮件',
    `schedule_type` varchar(50) NOT NULL DEFAULT 'NONE' COMMENT '调度类型',
    `schedule_conf` varchar(128) DEFAULT NULL COMMENT '调度配置，值含义取决于调度类型',
    `misfire_strategy` varchar(50) NOT NULL DEFAULT 'DO_NOTHING' COMMENT '调度过期策略',
    `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT '执行器路由策略',
    `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
    `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
    `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT '阻塞处理策略',
    `executor_timeout` int(11) NOT NULL DEFAULT '0' COMMENT '任务执行超时时间，单位秒',
    `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',
    `glue_type` varchar(50) NOT NULL COMMENT 'GLUE类型',
    `glue_source` mediumtext COMMENT 'GLUE源代码',
    `glue_remark` varchar(128) DEFAULT NULL COMMENT 'GLUE备注',
    `glue_updatetime` datetime DEFAULT NULL COMMENT 'GLUE更新时间',
    `child_jobid` varchar(255) DEFAULT NULL COMMENT '子任务ID，多个逗号分隔',
    `trigger_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '调度状态：0-停止，1-运行',
    `trigger_last_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '上次调度时间',
    `trigger_next_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '下次调度时间',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  
  CREATE TABLE `xxl_job_log` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `job_group` int(11) NOT NULL COMMENT '执行器主键ID',
    `job_id` int(11) NOT NULL COMMENT '任务，主键ID',
    `executor_address` varchar(255) DEFAULT NULL COMMENT '执行器地址，本次执行的地址',
    `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
    `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
    `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT '执行器任务分片参数，格式如 1/2',
    `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',
    `trigger_time` datetime DEFAULT NULL COMMENT '调度-时间',
    `trigger_code` int(11) NOT NULL COMMENT '调度-结果',
    `trigger_msg` text COMMENT '调度-日志',
    `handle_time` datetime DEFAULT NULL COMMENT '执行-时间',
    `handle_code` int(11) NOT NULL COMMENT '执行-状态',
    `handle_msg` text COMMENT '执行-日志',
    `alarm_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败',
    PRIMARY KEY (`id`),
    KEY `I_trigger_time` (`trigger_time`),
    KEY `I_handle_code` (`handle_code`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  
  CREATE TABLE `xxl_job_log_report` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `trigger_day` datetime DEFAULT NULL COMMENT '调度-时间',
    `running_count` int(11) NOT NULL DEFAULT '0' COMMENT '运行中-日志数量',
    `suc_count` int(11) NOT NULL DEFAULT '0' COMMENT '执行成功-日志数量',
    `fail_count` int(11) NOT NULL DEFAULT '0' COMMENT '执行失败-日志数量',
    `update_time` datetime DEFAULT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `i_trigger_day` (`trigger_day`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  
  CREATE TABLE `xxl_job_logglue` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `job_id` int(11) NOT NULL COMMENT '任务，主键ID',
    `glue_type` varchar(50) DEFAULT NULL COMMENT 'GLUE类型',
    `glue_source` mediumtext COMMENT 'GLUE源代码',
    `glue_remark` varchar(128) NOT NULL COMMENT 'GLUE备注',
    `add_time` datetime DEFAULT NULL,
    `update_time` datetime DEFAULT NULL,
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  
  CREATE TABLE `xxl_job_registry` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `registry_group` varchar(50) NOT NULL,
    `registry_key` varchar(255) NOT NULL,
    `registry_value` varchar(255) NOT NULL,
    `update_time` datetime DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  
  CREATE TABLE `xxl_job_group` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `app_name` varchar(64) NOT NULL COMMENT '执行器AppName',
    `title` varchar(12) NOT NULL COMMENT '执行器名称',
    `address_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '执行器地址类型：0=自动注册、1=手动录入',
    `address_list` text COMMENT '执行器地址列表，多地址逗号分隔',
    `update_time` datetime DEFAULT NULL,
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  
  CREATE TABLE `xxl_job_user` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `username` varchar(50) NOT NULL COMMENT '账号',
    `password` varchar(50) NOT NULL COMMENT '密码',
    `role` tinyint(4) NOT NULL COMMENT '角色：0-普通用户、1-管理员',
    `permission` varchar(255) DEFAULT NULL COMMENT '权限：执行器ID列表，多个逗号分割',
    PRIMARY KEY (`id`),
    UNIQUE KEY `i_username` (`username`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  
  CREATE TABLE `xxl_job_lock` (
    `lock_name` varchar(50) NOT NULL COMMENT '锁名称',
    PRIMARY KEY (`lock_name`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  
  INSERT INTO `xxl_job_group`(`id`, `app_name`, `title`, `address_type`, `address_list`, `update_time`) VALUES (1, 'xxl-job-executor-sample', '示例执行器', 0, NULL, '2018-11-03 22:21:31' );
  INSERT INTO `xxl_job_info`(`id`, `job_group`, `job_desc`, `add_time`, `update_time`, `author`, `alarm_email`, `schedule_type`, `schedule_conf`, `misfire_strategy`, `executor_route_strategy`, `executor_handler`, `executor_param`, `executor_block_strategy`, `executor_timeout`, `executor_fail_retry_count`, `glue_type`, `glue_source`, `glue_remark`, `glue_updatetime`, `child_jobid`) VALUES (1, 1, '测试任务1', '2018-11-03 22:21:31', '2018-11-03 22:21:31', 'XXL', '', 'CRON', '0 0 0 * * ? *', 'DO_NOTHING', 'FIRST', 'demoJobHandler', '', 'SERIAL_EXECUTION', 0, 0, 'BEAN', '', 'GLUE代码初始化', '2018-11-03 22:21:31', '');
  INSERT INTO `xxl_job_user`(`id`, `username`, `password`, `role`, `permission`) VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 1, NULL);
  INSERT INTO `xxl_job_lock` ( `lock_name`) VALUES ( 'schedule_lock');
  
  commit;
  ```

- 2）添加依赖&配置，具体参考官方文档

- 3）添加执行器配置类

  ```java
  @Configuration
  public class XxlJobConfig {
      @Value("${xxl.job.admin.addresses}")
      private String adminAddresses;
      @Value("${xxl.job.accessToken}")
      private String accessToken;
      @Value("${xxl.job.executor.appname}")
      private String appname;
      @Value("${xxl.job.executor.address}")
      private String address;
      @Value("${xxl.job.executor.ip}")
      private String ip;
      @Value("${xxl.job.executor.port}")
      private int port;
      @Value("${xxl.job.executor.logpath}")
      private String logPath;
      @Value("${xxl.job.executor.logretentiondays}")
      private int logRetentionDays;
  
      @Bean
      public XxlJobSpringExecutor xxlJobExecutor() {
          XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
          xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
          xxlJobSpringExecutor.setAppname(appname);
          xxlJobSpringExecutor.setAddress(address);
          xxlJobSpringExecutor.setIp(ip);
          xxlJobSpringExecutor.setPort(port);
          xxlJobSpringExecutor.setAccessToken(accessToken);
          xxlJobSpringExecutor.setLogPath(logPath);
          xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);
          return xxlJobSpringExecutor;
      }
  }
  ```

- 4）**添加实体类**

  ```java
  @Setter@Getter
  public class UserMobilePlan {
      private Long id;//主键
      private String username;//用户名
      private String nickname;//昵称
      private String phone;//手机号码
      private String info;//备注
  }
  ```

- 5）添加Mapper处理类

  ```java
  @Mapper
  public interface UserMobilePlanMapper {
      @Select("select * from t_user_mobile_plan")
      List<UserMobilePlan> selectAll();
  }
  ```

- 5）添加任务处理实现

  ```java
  @XxlJob("sendMsgHandler")
  public void sendMsgHandler() throws Exception{
      List<UserMobilePlan> userMobilePlans = userMobilePlanMapper.selectAll();
      System.out.println("任务开始时间:"+new Date()+",处理任务数量:"+userMobilePlans.size());
      Long startTime = System.currentTimeMillis();
      userMobilePlans.forEach(item->{
          try {
              //模拟发送短信动作
              TimeUnit.MILLISECONDS.sleep(10);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      });
      System.out.println("任务结束时间:"+new Date());
      System.out.println("任务耗时:"+(System.currentTimeMillis()-startTime)+"毫秒");
  }
  ```

- 假如该案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，如此则需要20多秒才能执行完任务，如果采取分片广播的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数来分配分片任务；

- 在配置了分片任务的调度方式后，任务调度的时候就可以同时调度多个实例进行处理，XXL-JOB 会给每个实例传递两个分片参数：

  - **分片总数（Sharding Total）**：表示任务被分成多少个分片，例如，如果设置为 3，那么表示任务被分成 3 片，表示集群中服务器的数量
  - **分片序号（Sharding Index）**：表示当前执行器执行的是哪一片的内容，最大值是分片总数减1.

  在任务执行的过程中，可以通过调用 XxlJobHelper.getShardIndex() 和XxlJobHelper.getShardTotal() 方法获取当前执行器的分片序号和总分片数

  ```java
  int shardIndex = XxlJobHelper.getShardIndex();
  int shardTotal = XxlJobHelper.getShardTotal();
  ```

  通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度.

- 之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务

### 任务分片优化

- Mapper增加查询方法：

```java
@Mapper
public interface UserMobilePlanMapper {
    @Select("select * from t_user_mobile_plan where mod(id,#{shardingTotal})=#{shardingIndex}")
    List<UserMobilePlan> selectByMod(@Param("shardingIndex") Integer shardingIndex,@Param("shardingTotal")Integer shardingTotal);
    @Select("select * from t_user_mobile_plan")
    List<UserMobilePlan> selectAll();
}
```

- 任务类方法：

```java
@XxlJob("sendMsgShardingHandler")
public void sendMsgShardingHandler() throws Exception{
    System.out.println("任务开始时间:"+new Date());
    int shardTotal = XxlJobHelper.getShardTotal();
    int shardIndex = XxlJobHelper.getShardIndex();
    List<UserMobilePlan> userMobilePlans = null;
    if(shardTotal==1){
        //如果没有分片就直接查询所有数据
        userMobilePlans = userMobilePlanMapper.selectAll();
    }else{
        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);
    }
    System.out.println("处理任务数量:"+userMobilePlans.size());
    Long startTime = System.currentTimeMillis();
    userMobilePlans.forEach(item->{
        try {
            TimeUnit.MILLISECONDS.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    System.out.println("任务结束时间:"+new Date());
    System.out.println("任务耗时:"+(System.currentTimeMillis()-startTime)+"毫秒");
}
```

